---
title: "[당신의 작업실] 10. 프로젝트를 마치며"
date: "2023-06-20T05:20:10.000Z"
description: "이번 프로젝트를 통해 얻은 것과 아쉬웠던 점을 공유합니다."
category: "project"
featuredImage: "../../../../../src/images/sideProject-256x256.png"
mobileImage: "../../../../../src/images/sideProject-512x256x2.png"
---
- 당신의 작업실 프로젝트 링크: https://pixel-workroom.herokuapp.com/
- 프로젝트 깃허브 저장소 링크 : https://github.com/ha-il/project-pixel

## 들어가기 전에 

이번 글에서는 프로젝트를 통해 무엇을 얻었고 어떤 점이 아쉬웠는지 이야기해보고, 그것을 기반으로 다음에는 무엇을 하면 좋을지에 대해서 이야기해보려 합니다. 

## 1.프로젝트를 통해 얻은 것

### 1.1 SPA에 대한 이해

제가 SPA를 처음 접했던 것은 리액트 강의를 들었을 때였습니다. 당시 저는 Express와 Pug를 이용해서 서버 측 렌더링을 하는 작은 프로젝트를 완성한 상태였고 리액트에 대해서 막 공부를 시작하려던 참이었습니다. 당시 저에게 페이지를 이동하면 새로고침이 일어나는 것은 너무 당연한 일이었습니다.

리액트 강의를 들으면서 `useState`라는 훅을 접했을 때, 새로고침 없이 페이지가 갱신되는 것을 보고 정말 마법 같은 기술이라고 생각했습니다. **상태에 따라서 새로고침 없이 렌더링을 한다니**, 그것도 페이지 전체를 렌더링하는 것이 아니라 **필요한 부분만을 렌더링하다니**. 정말 신기했습니다.

하지만 리액트로 코드를 작성할 때마다 찜찜한 부분이 있었습니다. 

**"내가 SPA를 이 useState라는 훅 하나로 구현해도 괜찮은 걸까? 이걸로 내가 SPA를 구현할 수 있다고 할 수 있을까?"**

이런 생각이 조금씩 들기 시작했습니다.

그 뒤로부터는 [이 글(이 프로젝트를 시작한 이유)](http://localhost:8000/side-project/project-pixel/1-motive/)에서 설명한 것처럼 바닐라 자바스크립트로 SPA를 구현해봐야겠다는 생각이 들었고 이 프로젝트를 시작하게 되었습니다.

그렇게 SPA를 구현하면서 아래와 같은 내용을 공부할 수 있었습니다.

1. 앱 전체가 아니라 원하는 컴포넌트만 렌더링 되어야 했으므로 **파일을 컴포넌트 단위로 구성**해야 했고, 그 과정에서 **객체지향 프로그래밍**과 **class**에 대해서 공부할 수 있었습니다.

2. 컴포넌트의 메서드를 구성하면서 **컴포넌트의 생명주기**에 대해서 고려할 수 있었습니다. 

3. 컴포넌트 간의 prop을 전달하는 경우 this 바인딩을 고려해야 하기 때문에 t**his와 this 바인딩을 유지하는 방법**을 공부할 수 있었습니다.

4. 렌더링되는 화면에 따라서 라우팅도 설정해줘야 했기 때문에 **History API와 Location API**에 대해서 공부할 수 있었습니다.

이렇게 굳이 바닐라 자바스크립트로 SPA를 구현하면서 많은 것들을 공부할 수 있었고, 추후에 리액트를 공부할 때도 좋은 배경이 되지 않을까 생각됩니다.


### 1.2 객체지향 프로그래밍에 대한 이해

이번 프로젝트를 하기 전까지 **객체 지향 프로그래밍**은 저에게 미지의 영역이었습니다. 

리액트 강의를 들었을 때도 class를 활용하기 보다는 hook을 사용해서 프로그래밍 하거나 함수 위주로 프로그래밍하는 경우가 더 많았습니다. 그런 이유로 (좀 부끄러운 이야기지만) 저는 '**객체지향으로 프로그래밍을 할 일이 없을지도 모르겠다**'라고 생각한 적도 있었습니다.

하지만 이번 프로젝트를 통해 객체지향 프로그래밍을 사용하는 것이 꽤 이해가 가고 심지어 꽤 재미있다고 느꼈습니다. Component라는 클래스를 만들고 그것을 바탕으로 다른 컴포넌트들을 작성하면서 '**클래스로 만들어서 미리 정의해두니까 정말 편하구나**'라는 생각이 들었습니다.

그냥 코드를 적게 작성해도 돼서 편한 것도 있었지만, 모든 컴포넌트가 하나의 클래스를 따르기 때문에 각기 다른 컴포넌트에서 프로그래밍을 해도, 그 **프로그래밍 경험이 일관되게 유지가 된다**는 점이 편리했습니다.

물론 어려운 점도 있었습니다. 모든 컴포넌트가 Component 클래스를 따르는 상황에서, 기**준이 되는 Component 클래스의 생명주기를 변경하면 모든 컴포넌트의 생명주기가 변경되기 때문에** 작업을 진행할 수록 Component 클래스에는 손을 댈 수가 없었습니다.

아직 이것으로 객체지향 프로그래밍을 이해했다고 말하기는 어렵겠지만, 객체지향 프로그래밍의 컨셉과, 장점과 단점에 대해서 대략적으로 파악할 수 있었던 좋은 기회였던 것 같습니다.

그리고 덤으로 자바스크립트의 **class와 this 바인딩**에 대해서 많이 공부할 수 있었습니다.

### 1.3 유저, 클라이언트, 서버 간의 통신 과정에 대한 이해

예전에 Express와 Pug를 이용해서 프로젝트를 만들었을 때는 서버 측에서 렌더링했기 때문에 클라이언트 측에서 데이터에 대한 요청을 보낼 일이 거의 없었고, 요청을 보내봤자 화면 렌더링과는 관계없는 api 요청이 전부였습니다. 리액트를 학습하면서부터는 클라이언트 측에서 데이터를 요청하여 화면을 렌더링하는 법을 배우긴 했지만 실제 프로젝트에 적용해 본 적은 없었습니다. 

특히 이번 프로젝트는 하나의 폴더에서 자바스크립트로 백엔드와 프론트엔드를 둘 다 다뤘기 때문에, 저에게는 그 영역의 경계가 특히 모호하게 느껴졌습니다. 그래서 이번 프로젝트를 할 때 **유저, 클라이언트, 서버 간의 통신 과정을 머릿 속으로 정리하는 것에 어려움을 많이 느꼈습니다**.

그런 어려움을 가장 크게 느꼈을 때가 유튜브 API를 활용할 때였습니다. 유저, 클라이언트, 서버 뿐만 아니라 유튜브 API 서버와도 통신해야 하는 상황이 오자 머리가 굉장히 복잡해졌습니다. 평소 프로그래밍을 하면서 뭔가를 생각해야 할 때가 오면 저는 보통 텍스트로 정리를 해왔지만, 이번에는 텍스트로는 부족해서 아래와 같이 **그림**을 그려보게 됐습니다. 

<img src="https://github.com/ha-il/ha-il.github.io/assets/108077643/2fe7d2b2-4e47-45a1-9f55-c475ed531e95" width="100%" alt="diagram"/>

(블로그에 올릴 줄 알았으면 글씨를 더 이쁘게 썼을 텐데요...😅)

</br>

한눈에 봐도 어설픈 그림이지만, 이 그림을 그리고나니 **유저, 클라이언트, 서버 사이의 통신 과정이 머릿속에 잘 그려졌습니다**. 그 이후로 유저가 이벤트를 발생시켜 클라이언트에서 fetch로 요청을 보내야 할 때마다 이런 식으로 그림을 그렸습니다.

그때는 잘 몰랐으나 지금 와서 생각해보니 제가 이런 형태의 그림을 어디서 봤던 기억이 있습니다. 바로 카카오 로그인 구현 방법에 대한 문서에 나왔던 **시퀀스 다이어그램**입니다.

<img src="https://developers.kakao.com/docs/latest/ko/assets/style/images/kakaologin/kakaologin_sequence.png" width="100%" alt="diagram"/>

(출처 - [kakao developers 카카오 로그인 REST API](https://developers.kakao.com/docs/latest/ko/kakaologin/rest-api))

제 어설픈 그림을 전문가가 만든 시퀀스 다이어그램에 비교하자니 조금 민망하지만, 이 경험을 통해 뭔가를 이해해야 할 때 **다이어그램**을 통해 대상이나 과정을 이해하는 것이 좋은 방법이 될 수 있겠다는 것을 배웠습니다. 

그리고 제가 급조해서 그린 그림이 시퀀스 다이어그램과 비슷한 형태를 띄고 있다는 사실에서 **제 자신이 클라이언트와 서버 사이의 관계를 나름 잘 이해하고 표현했다**는 자신감을 얻었습니다.

생각해보니 시퀀스 다이어그램을 카카오 로그인 문서에서 처음 본 것도 아니었습니다. 정보처리기사를 준비하면서 여러 종류의 다이어그램을 암기했었는데 그때도 봤던 기억이 있습니다. 그때는 이게 뭔 줄도 모르고 암기했습니다. '이걸 내가 쓸 일이 있을까?' 싶었지만, 지금은 누가 시키지 않아도 시퀀스 다이어그램 비슷한 것을 그리고 있는 제 자신을 보니, '전부 다 쓸 일이 있으니까 시험에 나오는 것이구나'라는 생각도 들었습니다. 

## 2. 아쉬웠던 점

### 2.1 검색 기능을 제대로 구현하지 못했던 것

[이전 글](https://ha-il.github.io/side-project/project-pixel/9-dev-regexp/)에서도 다뤘듯이 이 프로젝트의 음악 검색 기능은 매우 부실했습니다. 검색 기능을 업데이트하기 전에 프로젝트의 첫 번째 버전을 배포했었는데요. 감사하게도 몇몇분이 프로젝트를 이용해주시고 피드백도 남겨주셨는데, 이때 '내가 추가한 음악을 검색할 수 없어요'라는 피드백을 받았습니다. 

그 피드백을 받고 굉장히 후회를 많이 했었습니다. 제가 예상했던 부분이 아니라 안심하고 있었던 부분에서 버그가 발생해서 더욱 뼈아팠던 것 같습니다. 

'**정규 표현식 조금만 더 검색하면 나오는 건데 왜 그걸 안 했을까**', 

'**우선 개발해야 하는 주요 기능이 있다고 해도, 검색 기능도 못지 않게 중요한데 왜 그걸 소홀히 했을까**' 

여러가지 생각이 밀려왔습니다. 

나름 완성됐다는 생각으로 배포했지만 여전히 부족한 점이 있는 것을 보고, '**언제나 100% 완성이라는 것은 없다**'는 사실을 깨달았습니다. 

그리고 **테스트**에 관심을 갖게 되었습니다. 검색 기능을 제대로 테스트했다면 이런 일이 없지 않았을까 싶습니다. 테스트를 설계하는 방법, 테스트 케이스를 구성하는 방법, 테스트를 진행하는 방법 등을 배워보고 싶다는 생각이 들었습니다.

### 2.2 상태관리를 제대로 하지 못 했던 것

프로젝트 기획을 시작할 때는 상태관리의 필요성을 특별히 느끼지 못했습니다. 프로젝트에서 사용할 컴포넌트 수가 그렇게 많지 않을 것 같고, 컴포넌트 사이의 깊이도 그렇게 깊지 않을 것 같았습니다. 그저 prop을 전달하는 것으로 충분할 것이라 생각했습니다.

하지만 본격적으로 개발에 들어가니 prop을 전달할 일이 상당히 빈번하게 발생했습니다. **심지어 해당 prop이 필요하지 않은 컴포넌트에도 오직 다른 컴포넌트로 전달하기 위해 prop을 전달하기도 했습니다**. 

['prop과 this 바인딩'](https://ha-il.github.io/side-project/project-pixel/8-dev-prop-this/)에서 MusicPlayer 클래스의 setState 메서드를 `playerSetState`에 담아서 prop으로 전달하는 과정을 설명한 적이 있습니다. `playerSetState`는 prop에 담겨서 **플레이리스트 페이지**로 전달됩니다. 

여기서 문제가 발생했습니다. **플레이리스트 페이지로 진입할 수 있는 모든 곳에 `playerSetState`를 prop으로 전달해주어야 했습니다.** 홈페이지, 스마트폰 오브젝트, 장식장 오브젝트에서 플레이리스트 페이지로 진입하는 경우 플레이리스트 페이지로 `playerSetState`를 prop으로 넘겨줘야 했습니다. 

예시를 통해 `playerSetState`가 어떤 과정으로 전달되고 있는지 소개하겠습니다.

```javascript
// playerSetState의 여행 과정

class App extends Component {
  addComponent() {
    const musicPlayer = new MusicPlayer($("#music-player"));
    // App 에서 Home 출발 ~
    return new Home($("main"), {
      playerSetState: musicPlayer.setState,
    });
  }
}
```
```javascript
class Home extends Component {
  setEvent() {
    $(".home-container").addEventListener("click", (e) => {
        const { playerSetState } = this.props;
        // Home 에서 Phone으로 출발 ~
        // 어라? 근데 Phone에서는 playerSetState 쓸일 없는데?
        return new Phone($("#phone"), {
          $main: this.$target,
          playerSetState,
        });
    });
  }
}
```
```javascript
class Phone extends Component {
  addComponent() {
    const { $main, playerSetState } = this.props;
    // Phone에서 PhoneHome으로 출발...
    return new PhoneHome($(".phone-container"), { $main, playerSetState });
  }
}
```
```javascript
class PhoneHome extends Component {
  setEvent() {
    $("#playlist-creation").addEventListener("click", (e) => {
      const { $main, playerSetState } = this.props;
      // PhoneHome에서 PlaylistCreation으로 출발...
      new PlaylistCreation($(".phone-container"), { $main, playerSetState });
    });
  }
}
```
```javascript
class PlaylistCreation extends Component {
  setEvent() {
    $("#playlist-creation-form").addEventListener("submit", async (e) => {
        const { $main, playerSetState } = this.props;
        // PlaylistCreation에서 Playlist로 출발...
        // 아.. 여기서 Playlist로 playerSetState를 전달해줘야 해서,
        // 이 먼 길을 왔구나...
        new Playlist($main, { $main, playerSetState });
    });
  }
}
```
```javascript
class Playlist extends Component {
  setEvent() {
    $(".play-button").addEventListener("click", (e) => {
      if (this.state.playlist.musics.length === 0) return;
      const { playerSetState } = this.props;
      // 드디어 도착 ㅜㅜ
      return playerSetState({
        musics: this.state.playlist.musics,
        currentMusic: this.state.playlist.musics[0],
      });
    });
  }
}
```
검색해보니 이런 상황을 **prop drilling**이라고 부르는 것 같습니다. 그리고 이에 대한 해결책으로 상태관리 라이브러리가 등장했다고 하니, 이번 프로젝트를 통해 상태관리 라이브러리의 필요성을 절실히 느끼게 되었습니다.

prop에 대한 전달을 고려하지 않고 컴포넌트 간의 깊이를 너무 깊게 설정한 저의 설계 부족도 있는 것 같아서 더 아쉽습니다.


### 2.3 플레이리스트 컴포넌트에 너무 많은 코드를 작성했던 것

플레이리스트 컴포넌트 안에 너무 많은 코드를 작성해서 컴포넌트 방식의 이점을 살리지 못한 것이 아쉬웠습니다. 

플레이리스트 컴포넌트는 플레이리스트 상세 페이지를 렌더링하는 컴포넌트로, 단일 컴포넌트로 사용하기에는 기능도 많고 불러오는 데이터도 많은 컴포넌트입니다. 

사실 분리가 불가능한 것은 아니었습니다만, 분리가 필요하다고 느꼈을 때는 이미 너무 많은 코드를 해당 컴포넌트에 작성을 해버린 상태였습니다.

개인 프로젝트라 마감 기한을 무시하고 진행할 수도 있었지만, '**기한에 맞춰서 기능을 개발하는 것**'과 '**기한에 맞추지 못해도 더 좋은 코드로 개발하는 것**' 중에 뭐가 더 중요할까 라는 고민에 '`일단 기한을 맞추는 것이 중요하다`'라는 결론을 내습니다. 

다행히 마감 기한으로 정해뒀던 1차 배포 날까지 프로젝트를 완성시킬 수 있었고, 기능도 대부분 제대로 동작했습니다. 하지만 코드에 대한 아쉬움은 여전히 남아있습니다.

## 3. 앞으로 하고 싶은 일

배웠던 것도 많고 아쉬웠던 것도 많은 프로젝트였기에 앞으로 해보고 싶은 일들도 많이 생겼습니다. 

### 3.1 프로젝트 리팩터링

사실 이 글을 쓰고 있는 순간에도 타입스크립트와 리액트를 배우러 가고 싶다는 마음이 굴뚝 같지만, 지금 머릿속에 당장 떠오르는 수정 사항만 해도 적지 않기 때문에, 프로젝트에 대한 최소한의 리팩터링은 해야할 것 같습니다.

마감기간을 맞추느라 **구현하지 못했던 기능들을 추가**할 예정이고, 아쉬운 점으로 꼽았던 **플레이리스트 컴포넌트**를 리팩터링을 해보고 싶습니다.

### 3.2 함수형 프로그래밍에 대한 공부

사실 이 프로젝트가 끝나고 프로그래머스에서 진행하는 프론트엔드 데브매칭이라는 채용 프로그램에 참가했습니다. 이 프로그램에서는 과제 테스트를 보게 되는데, 바닐라 자바스크립트로만 진행됩니다. 이번을 포함해서 총 3번 참가했는데 여태 이력은 이렇습니다.

- 1차: 기능 구현도 제대로 못하고 탈락
- 2차: 기능은 어느정도 구현했지만 그저 그런 코드로 턱걸이 합격
- 3차: 기능도 대부분 구현했고 class 활용하여 SPA로 구현 => 현재 결과 기다리는 중

이 얘기를 왜 굳이 꺼냈냐면, 이번 데브매칭의 과제 테스트를 볼 때 속으로 이렇게 생각했습니다. 

"**이젠 class를 안 쓰면 바닐라 자바스크립트로 어떻게 코딩을 해야 할 지 모르겠네**"

class에 익숙해졌으니 오히려 좋아해야 하려나요? 다만 저는 **특정 방식에 익숙해지고 있는 제 자신이 좀 걱정됐습니다**.

이번 프로젝트를 통해서 객체지향 프로그래밍의 맛을 알 수 있었듯이, 다음에는 **함수형 프로그래밍**을 배워보면 좀 더 다양한 방식으로 코딩을 할 수 있을 것 같다는 생각이 들었습니다. 

### 3.3 HTTP에 대한 공부

HTTP에 대한 공부를 마음 먹은 이유는 제가 SPA를 구현해야겠다고 마음 먹은 이유와 비슷한 것 같습니다.

**"내가 fetch로 요청 몇 번 보내봤다고, 클라이언트와 서버 간의 통신을 이해했다고 말할 수 있을까?"**

클라이언트와 서버 간의 통신을 하는 것을 넘어서 **제대로 이해하고 싶다**는 생각이 들었습니다. 



## 마치며

기획부터 개발 그리고 배포까지. 처음부터 끝까지 혼자서 했던 작업이라 힘들기도 힘들었지만 그만큼 뿌듯한 프로젝트였습니다.  그리고 **그 뿌듯함의 크기는 이 프로젝트를 하면서 만났던 문제의 양과 비례하는 것 같습니다.** 

혼자서 하는 프로젝트는 강의를 따라서 만든 프로젝트와 너무나도 달랐습니다. 처음 보는 에러도 많았고, 새로 공부해야할 것도 많았습니다. 

하지만 재미있게도 **모든 문제의 해결책은 이미 존재했습니다**. 단지, 그 해결책을 찾는 방법에 따라 시간이 오래 걸릴 뿐이었습니다.

이번 프로젝트를 통해 얻은 가장 큰 수확은, "**어떤 문제가 와도 반드시 해결할 수 있을 것이다.**"라는 믿음이 아닐까 싶습니다.

혹여나 글이 10개가 되는 이 시리즈를 모두 읽어주신 분이 계시다면, 이 자리를 빌어서 감사의 마음을 전달 드리고 싶습니다. 여태까지 긴 글 읽어주셔서 정말 감사합니다.

다음에도 새로운 프로젝트를 들고 찾아뵙겠습니다.