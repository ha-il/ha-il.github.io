---
title: "슬라이딩 윈도우(Sliding Window)패턴과 분할과 정복"
date: "2023-04-28T16:00:00.000Z"
description: "슬라이딩 윈도우 패턴을 학습하고 문제를 풀어봤습니다."
category: "Algorithm"
featuredImage: "../../../../src/images/algorithm-256x256.png"
mobileImage: "../../../../src/images/algorithm-512x256x2.png"
---
## 문제 해결 패턴 - 슬라이딩 윈도우(Sliding Window)

이번에는 [지난 포스팅](https://ha-il.github.io/algorithm-study/4-week/)에 이어서 또다른 문제 해결 패턴을 소개하겠습니다.

이번에 소개할 패턴은 슬라이딩 윈도우 패턴입니다.

여태까지 소개했던 ['빈도수 세기'](https://ha-il.github.io/algorithm-study/3-week/) 패턴과 ['다중 포인터'](https://ha-il.github.io/algorithm-study/4-week/) 패턴에 비해서는 꽤 재미있는 이름입니다.

왜 슬라이딩 윈도우라는 이름이 붙었는지는 예시를 통해 보여드리는게 이해가 빠를 것 같습니다.

- 예시: 슬라이딩 윈도우의 원리

  1회차: [`1, 2`, 3, 4, 5]

  2회차: [1, `2, 3`, 4, 5]

  3회차: [1, 2, `3, 4`, 5]

  4회차: [1, 2, 3, `4, 5`]

위의 예시를 보면 정말 미닫이 창문이 움직이는 것처럼 배열을 탐색하고 있는 것을 확인할 수 있습니다.

이처럼 슬라이딩 윈도우 패턴은, 배열이나 문자열 같은 데이터의 하위 집합을 찾는 경우에 유용합니다.

슬라이딩 윈도우 패턴에서 중요한 것은 `창문의 길이`입니다. 

(참고: 창문의 크기, 너비, 가로 폭 등 다양한 용어가 있지만, 슬라이딩 윈도우 패턴은 `배열이나 문자열의 길이`와 연관이 있기 때문에, 이번 글에서는 `창문의 길이`라는 표현을 사용하도록 하겠습니다.)

창문의 길이는 주어진 문제에 따라서 달라질 수 있습니다.

매개변수로 주어진 수를 창문의 길이로 활용할 수 있다면, 해당 문제에서는 고정된 길이를 가진 슬라이딩 윈도우 패턴을 활용할 수 있습니다.

위에서 보여드렸던 '예시: 슬라이딩 윈도우의 원리'를 보시면 고정된 길이의 창문이 움직이고 있는 것을 확인할 수 있습니다.

고정된 길이가 주어지지 않거나, 오히려 길이가 변해야만 하는 경우도 슬라이딩 윈도우 패턴을 사용할 수 있습니다.

- 예시: 슬라이딩 윈도우의 원리(창문의 길이가 변하는 경우)

  1회차: [`1, 2`, 3, 4, 5]

  2회차: [`1, 2, 3`, 4, 5]

  3회차: [`1, 2, 3, 4`, 5]

  4회차: [`1, 2, 3, 4, 5`]

  5회차: [1, `2, 3, 4, 5`]

  6회차: [1, 2, `3, 4, 5`]

  n회차 : ...

창문의 길이가 변하는 경우는 창문을 늘리거나 줄일 수 있기 때문에, 조건에 따라서 다양한 경우의 수가 나올 수 있습니다.

슬라이딩 윈도우 패턴은 문제에 따라서 정말 다양하게 구현할 수 있지만, 대표적인 경우로 `'창문의 고정적인 길이가 주어진 경우'` 그리고 `'창문의 길이가 변하는 경우'` 이렇게 두 가지 경우를 뽑을 수 있을 것 같습니다.

따라서 이번 글에서는 위의 두 가지 경우를 기반으로 슬라이딩 윈도우 패턴의 일반적인 형태를 알아보고, 패턴을 적용해서 실제 코딩테스트 문제를 하나 풀어보도록 하겠습니다.


### 슬라이딩 윈도우 패턴의 일반적인 형태

위에서 살펴본 두 가지 경우의 일반적인 형태를 알아보도록 하겠습니다.

대부분의 문제에 적용할 수 있도록 최대한 추상적으로 작성했으나, 적용하고자 하는 문제에 따라서 코드 작성 방법은 얼마든지 달라질 수 있습니다.

슬라이딩 윈도우 패턴을 코드로 작성하면 대략 이런 형태를 가지는구나 정도로 봐주시면 될 것 같습니다.

#### 창문의 고정적인 길이가 주어진 경우

```javascript
function slidingWindow(arr, num){
  
  // 1. 최종적으로 반환할 값을 할당할 변수 result를 선언합니다.
  //    비교에 사용할 임시 변수 temp도 선언합니다.
  let result = 0;
  let temp = 0;

  // 2. 주어진 배열 arr의 길이가 창문의 길이 num보다 작을 경우를 처리할 코드를 작성합니다.
  if (arr.length < num) return null; // 반드시 null을 반환해야하는 것은 아닙니다.

  // 3. arr의 첫번째 요소부터 창문의 길이(num)에 포함되는 요소까지 연산을 진행합니다.
  //    연산 결과를 result에 저장합니다.
  for (let i = 0; i < num; i++) {
    result += arr[i];
  }

  // 4. 반복문의 연산 결과를 임시 변수 temp에 저장합니다.
  temp = result;

  // 5. 창문의 앞 부분은 잘라내고, 뒷 부분은 붙여서 창문을 이동시키면서 결과값을 찾습니다.
  //    앞 부분을 잘라낸다 === temp - arr[i - num]
  //    뒷 부분을 붙인다 === + arr[i];
  for (let i = num; i < arr.length; i++) {
    temp = temp - arr[i - num] + arr[i];
    result = // 상황에 따라 result 또는 temp를 저장합니다.
  }
  // 6. 최종값 result를 반환합니다.
  return result;
}

```



#### 창문의 길이가 변하는 경우

```javascript
function slidingWindow(arr, num) {

  // 1. 최종적으로 반환해야 할 값과, 임시로 저장할 값을 선언합니다.
  let result = 0;
  let temp = 0;

  // 2. 창문의 길이가 변하기 때문에, 창문의 시작과 끝에 해당하는 변수도 선언합니다.
  let start = 0;
  let end = 0;
 
  // 3. 반복문을 작성합니다.
  //    반복문 종료 조건은 보통 start 인덱스가 배열의 끝에 도달하는 경우가 됩니다.
  while (반복문 종료 조건) {
    
    // 4. 조건문을 작성합니다.
    //    문제에 따라 조건은 다양해지지만, 포함되어야 하는 연산은 아래와 같습니다.
    if(조건){
      // end 인덱스에 해당하는 요소를 추가하고 end 인덱스를 증가시킵니다. (창문의 크기를 늘리는 연산)
      temp += arr[end];
			end++;
    }
    else {
      // start 인덱스에 해당하는 요소를 제거하고 start 인덱스를 증가시킵니다. (창문의 크기를 줄이는 연산)
			temp -= arr[start];
			start++;
    } 
    // 이런 식으로 창문의 길이를 늘리고 줄여가며, start 인덱스가 배열의 끝에 도달했을 때 조건문은 종료됩니다.
  }
 
  // 4. 최종값을 반환합니다.
  return result;
}
```


### 패턴의 적용

패턴을 배웠으니 실전에 적용해보려고 합니다.

이번에도 프로그래머스에서 문제를 하나 가져왔습니다.

이번에 준비한 문제는, 프로그래머스 코딩테스트 연습 Lv.0 문제 [옹알이 (1)](https://school.programmers.co.kr/learn/courses/30/lessons/120956)입니다.

이번에도 역시 [저번 포스팅](https://ha-il.github.io/algorithm-study/2-week/)에서 배웠던 것처럼 문제 해결 접근법을 적용해서 풀어봤습니다.

먼저 문제를 잠깐 보실까요?

```
머쓱이는 태어난 지 6개월 된 조카를 돌보고 있습니다. 
조카는 아직 "aya", "ye", "woo", "ma" 
네 가지 발음을 최대 한 번씩 사용해 조합한(이어 붙인) 발음밖에 하지 못합니다. 
문자열 배열 babbling이 매개변수로 주어질 때, 
머쓱이의 조카가 발음할 수 있는 단어의 개수를 return하도록 solution 함수를 완성해주세요.
```
이 문제를 조금 더 간결하게 설명하면, 주어진 문자열이 "aya", "ye", "woo", "ma"로만 이뤄져 있는지를 판별하는 함수를 작성하라는 것입니다.

저는 이 문제를 보자마자 슬라이딩 윈도우 패턴을 적용하면 풀 수 있을 것 같다는 생각이 들었습니다.

예를 들어 "yemawoo"라는 문자열이 있다고 가정했을 때, 저는 아래와 같은 방식으로 문자열을 순회하면 문제를 풀 수 있을 것 같다고 생각했습니다.

- 1회차: `y`emawoo / 단어의 개수: 0

- 2회차: `ye`mawoo / 단어의 개수: 1

- 3회차: ye`m`awoo / 단어의 개수: 1

- 4회차: ye`ma`woo / 단어의 개수: 2

- 5회차: yema`w`oo / 단어의 개수: 2

- 6회차: yema`wo`o / 단어의 개수: 2

- 7회차: yema`woo` / 단어의 개수: 3

슬라이딩 윈도우 패턴 중에서도 창문의 길이 변하는 경우를 활용하면 이 문제를 풀 수 있을 것 같았습니다.

상세한 풀이는 아래 코드에서 설명드리겠습니다.

#### '옹알이 (1)'의 문제 해결 접근법 적용

```javascript
/*
머쓱이는 태어난 지 6개월 된 조카를 돌보고 있습니다. 
조카는 아직 "aya", "ye", "woo", "ma" 네 가지 발음을 최대 한 번씩 사용해 조합한(이어 붙인) 발음밖에 하지 못합니다. 
문자열 배열 babbling이 매개변수로 주어질 때, 머쓱이의 조카가 발음할 수 있는 단어의 개수를 return하도록 solution 함수를 완성해주세요.
*/

/* 문제 이해하기
- 이해
  - 배열 babbling의 요소인 문자열이 "aya", "ye", "woo", "ma"의 조합으로만 이루어져 있는지 확인하기
  - 해당 문자열을 확인할 때 슬라이딩 윈도우 패턴을 사용하기.
- 인풋
  - babbling: 길이가 1~100인 배열
  - babbling[i]: 길이가 1~15인 문자열, 알파벳 소문자로만 이뤄져 있다.
- 아웃풋
  - answer: "aya", "ye", "woo", "ma"의 조합으로만 이루어져 있는 문자열의 개수
- 네이밍
  - babbling: 인풋 배열
  - babbles: 조합 가능한 문자열의 배열
  - start: 배열의 첫 인덱스
  - answer: babbling 배열에서 babbles의 조합으로 이뤄져있는 요소의 개수
  - str: babbling에서 현재 탐색 중인 문자열
  - seen: str에서 탐색이 완료된 문자들을 문자열로 저장하는 변수
*/

/* 예시
조합 가능 문자열 "aya", "ye", "woo", "ma"

["ayaye", "uuuma", "ye", "yemawoo", "ayaa"] // 3
["aya", "yee", "u", "maa", "wyeoo"] // 1
*/

function solution(babbling) {
  // "aya", "ye", "woo", "ma"를 배열로 저장할 변수 babbles를 선언합니다.

  // 최종적으로 반환해야할 값 answer를 선언하고 0을 할당합니다.

  // babbling을 순회하는 반복문을 작성하고, babbling의 요소는 str로 선언합니다.
    // 창문의 시작에 해당하는 변수 start를 선언하고 0을 할당합니다.
    // str을 순회하는 반복문을 작성합니다.
    // 반복문에 사용할 변수는 창문의 끝에 해당하는 end를 선언하고 0을 할당합니다.
      // start와 end 범위의 문자열을 할당할 변수 seen을 선언합니다.
      // 조건문을 작성합니다.
        // 만약 seen이 babbles에 해당되고 end가 str의 마지막 인덱스와 같은 값을 가진다면,
          // str이 babbles의 조합으로 이뤄졌고 순회도 끝났다는 의미이므로
          // answer에 값을 1 더해줍니다.
        // 만약 seen이 babbles에 해당되지만 아직 str의 순회가 완료되지 않았다면
          // start에 end + 1을 더해서 str을 마저 순회합니다.
  // answer를 반환합니다.
}
```

#### '옹알이 (1)'의 슬라이딩 윈도우 패턴 적용

패턴을 적용해서 코드를 작성했습니다.

```javascript
function solution(babbling) {
  const babbles = ["aya", "ye", "woo", "ma"];
  
  let answer = 0;
  
  for (str of babbling) {  
    let start = 0;
    for (end = 0; end < str.length; end++) {
      let seen = str.slice(start, end + 1);
      if (babbles.includes(seen) && end === str.length - 1) {
        answer += 1;
      } else if (babbles.includes(seen)) {
        start = end + 1;
      }
    }
  }

  return answer;
}

solution(["ayaye", "uuuma", "ye", "yemawoo", "ayaa"]); // 3
solution(["aya", "yee", "u", "maa", "wyeoo"]); // 1

```
위와 같이 제출했더니 무사히 통과할 수 있었습니다.

### 추가: 분할과 정복 패턴

분할과 정복 패턴은 중요한 문제 해결 패턴이고, 앞으로 배울 탐색이나 정렬 알고리즘에도 많이 사용되는 패턴입니다.

본격적으로 탐색과 정렬 알고리즘을 배우기 전에, 해당 알고리즘에 자주 사용되는 분할과 정복 패턴을 가볍게 훑어보고자 추가적으로 작성했습니다.


#### 분할과 정복 패턴이란?

아래와 같이 오름차순으로 정렬된 배열이 있다고 가정해보겠습니다. 

[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 

이 배열에서 숫자 8을 찾을 수 있는 방법은 뭐가 있을까요?

아마 가장 먼저 떠오르는 것은 이런 방법일지도 모르겠습니다.

- 1회차: [`1`, 2, 3, 4, 5, 6, 7, 8, 9, 10] 
- 2회차: [1, `2`, 3, 4, 5, 6, 7, 8, 9, 10] 
- 3회차: [1, 2, `3`, 4, 5, 6, 7, 8, 9, 10] 
- ...
- 8회차: [1, 2, 3, 4, 5, 6, 7, `8`, 9, 10] 

배열의 처음부터 끝까지 순회하여 값을 찾는 방법도 지금은 괜찮아 보이지만,

이 배열이 굉장히 길고, 내가 찾고자하는 값이 배열의 맨 뒤에 있다면 어떨까요?

그렇다면 이 방법이 효율적이라고 보기는 좀 어려울 수 있습니다.

이때 분할과 정복 패턴이 효율적인 문제 해결 방법으로 사용될 수 있습니다.

분할과 정복 패턴은 아래와 같은 방식으로 배열을 순회하여 목표로 하는 값(8)을 찾아냅니다. 

- 1회차: [1, 2, 3, 4, 5, `6, 7, 8, 9, 10`] 
- 2회차: [1, 2, 3, 4, 5, 6, 7, `8, 9, 10`] 
- 3회차: [1, 2, 3, 4, 5, 6, 7, `8, 9`, 10] 
- 4회차: [1, 2, 3, 4, 5, 6, 7, `8`, 9, 10] 

똑같이 8을 찾고 있지만, 연산 횟수가 줄어든 것을 확인할 수 있습니다.

이처럼 분할과 정복 패턴은 `중간값`을 가지고 데이터를 두 영역으로 분할합니다.

그리고 원하는 값을 찾을 때까지 이 과정을 반복합니다.

#### 분할과 정복 패턴의 형태

이런 분할과 정복 패턴에서 중요한 요소는 어떤 것이 있을까요?

당연히 `중간값`이 중요한 요소일 것입니다.

그러면 이런 중간값을 구하기 위해서는 또 어떤 요소가 필요할까요?

중간이라는 것은 시작과 끝의 중간이라는 의미이기 때문에,

`시작값`과 `끝값`이 필요할 것입니다.

이 세 가지 값을 가지고 어떻게 분할과 정복 패턴을 코드로 작성할 수 있는지 소개하겠습니다.

위에서 예시로 소개했던, 배열(arr)에서 원하는 숫자(val)를 찾아 그 숫자의 인덱스를 반환하는 search라는 함수를 작성해보겠습니다.

```javascript
function search(arr, val) {
  // 1. 시작값 start와 끝값 end를 선언하고, 
  //    배열의 시작 인덱스 0과 끝 인덱스 arr.length - 1을 각각 할당합니다.
  let start = 0;
  let end = arr.length - 1;

  // 2. 반복문을 작성합니다.
  //    반복문은 start값이 end값보다 커지기 전까지는 계속 반복합니다.
  while (start <= end) {

    // 3. 중간 값을 할당할 변수 middle을 선언하고, 중간값을 할당합니다.
    let middle = Math.floor((start + end) / 2);

    // 4. arr[middle]과 val을 비교하여 세 가지 조건문을 작성합니다.
    if (arr[middle] > val) {
      end = middle - 1;
    } else if (arr[middle] < val) {
      start = middle + 1;
    } else {
      // 5. arr[middle]과 val가 같다면 middle값(val의 인덱스 값)을 반환합니다.
      return middle;
    }
  }

  // 5. 반복문이 종료되었음에도 middle 값이 반환되지 않았다면
  //    해당 배열(arr)에 val이 없다는 의미이므로 -1을 반환합니다.
  return -1;
}
```


### 회고

프로그래머스의 옹알이1 문제는 제가 해당 사이트에서 가장 처음 접했던 코딩 테스트 문제였습니다.

이 문제를 처음 접했을 때는 어떻게 접근해야할지 감도 안 잡혔고, 중첩 반복문은 커녕 중첩에 중첩에 중첩을 시켜서 문제를 풀려고 했었고 결국 포기했던 기억도 납니다.

문제 해결 패턴에 대해서 공부를 하고 문제를 다시 풀어보니, 예전과는 확실히 달라진 저를 느낄 수 있었습니다.

아직 알고리즘이나 자료구조를 많이 배운 것도 아니지만, 어렵게 보이던 문제들이 하나 둘씩 풀려나가는 것을 보면 신기하다는 느낌이 듭니다.

앞으로 배워야 할 것들이 많은데, 이런 것들을 배우면 더 어려운 문제도 풀 수 있을 것 같다는 기대가 되면서 설레는 마음도 조금은 드는 것 같습니다.

오늘 글은 여기서 마치겠습니다.

감사합니다.


### 참고자료

- 프로그래머스 코딩 테스트 연습 - 옹알이 (1)

문제 링크: [https://school.programmers.co.kr/learn/courses/30/lessons/120956](https://school.programmers.co.kr/learn/courses/30/lessons/120956)

- Best JavaScript Data Structures & Algorithms Course by Udemy, last updated January 2022, accessed April 5, 2023
강의 링크: [https://www.udemy.com/course/best-javascript-data-structures/](https://www.udemy.com/course/best-javascript-data-structures/)