---
title: '[리액트 딥 다이브] 리액트에서 의존성 역전 다루기'
date: '2023-09-09T16:17:00.000Z'
description: 'ContextAPI는 전역 관리 도구가 아니다.'
category: 'react'
featuredImage: '../../../../../src/images/react-256x256.png'
mobileImage: '../../../../../src/images/react-512x256x2.png'
---

## 1. 의존성

의존성이란 특정한 모듈이 동작하기 위해서 다른 모듈을 필요로 하는 것을 의미한다. 아래 코드를 잠깐 확인해보자.

```js
// fetch(path, options):void

fetch("profile", {
	headers:{
		Authorization:localStorage.getItem("ACCESS_TOKEN");
	}
}
```
fetch 함수는 localStorage에서 토큰을 받아와서 path로 api 요청을 보내서 현재 로그인 중인 유저의 프로필을 받아오는 함수다. fetch 함수의 경우 localStorage라는 외부 요소에 의존하고 있다. 이처럼 하나의 모듈이 동작하기 위해서 다른 모듈을 필요로 하는 것을 의존성이라고 하며, fetch 함수는 localStorage에 의존하고 있다.

이 코드에는 문제점이 있다. fetch라는 함수가 localStorage라는 '구체(concretion)'에 의존하고 있다는 점이다.

## 2. 구체에 의존하는 게 뭐가 나쁘죠?:

먼저, '구체'라는 개념에 대해서 간략하게 알아보자.

- 구체(concretion): 실질적으로 해당 동작을 하기 위해서 수행해야 하는 구체적인 동작과 흐름을 말한다. 
  
나는 위에서 localStorage가 '구체'라고 말했다. 그 이유는 뭘까? localStorage를 사용하는 코드는 달랑 한 줄이고 그 길이도 길지 않지만 다음과 같은 구체적인 흐름을 가지고 실행된다.  

1. localStorage의 getItem 메서드를 사용한다.
2. getItem 메서드에 "ACCESS_TOKEN"을 인자로 보낸다.
3. localStorage에서 데이터를 받아온다.

이렇게 fetch라는 함수는 localStorage라는 '구체'에 의존하고 있음을 확인할 수 있다. 하지만 이게 뭐가 나쁘다는 것일까?

만약 토큰을 저장하는 방식을 localStorage가 아닌 다른 스토리지를 사용하도록 바꾸면 어떻게 될까? fetch 함수를 사용하는 곳은 물론이고, localStorage를 사용하는 모든 곳에서 코드를 수정해야 한다. 즉, 구체에 의존하면 앱의 유지보수가 어려워진다.

유지보수 외에도 관심사에 대한 문제도 있다. fetch라는 함수의 관심사는 토큰을 가지고 profile 정보를 받아오는 것에 관심을 가지고 있다. 토큰을 어디서 어떻게 가지고 오는 지는 fetch 함수의 관심사가 아니다. fetch 함수 입장에서는 localStorage를 쓰든, 세션 스토리지를 쓰든, getItem 메서드를 쓰든, get어쩌구 메서드를 쓰든 그런 건 관심없고 그냥 토큰만 있으면 되는 것이다.

그러면 구체에 의존하는 이 상황을 무엇에 의존하도록 수정하면 좋을까? 위에서 잠깐 말 했듯 fetch 함수는 토큰을 받아오는 로직이 아니라, 토큰만 필요한 것이다. 즉, 토큰을 받아오는 로직을 다른 함수로 분리하고, 그 함수의 반환 값에만 의존하도록 수정하면 되지 않을까?

이렇게 어떤 모듈의 구체적인 동작이나 흐름에 의존하지 않고, 그저 그 모듈의 결과에 의존하는 것을 '추상'에 의존한다고 말한다. 그리고 구체가 아닌 추상에 의존하는 것을 '의존성 역전'이라고 표현한다.

## 3. 추상에 의존하는 게 뭐가 좋다는 거죠?

먼저, '추상'이라는 개념에 대해서 간략하게 알아보자.

- 추상(concretion): 구현 방법이 포함되어 있지 않고, 해당 모듈이 해줘야 하는 일과 결과만 신경쓸 수 있게 표현하는 것을 말한다.

모듈을 함수라고 생각하면 이해가 조금 더 쉽다. 쉽게 말하면 어떤 함수 A가 다른 함수 B를 호출할 때, A라는 함수는 B라는 함수의 인자와 반환값에만 관심을 갖는 것을 의미한다. B라는 함수가 인자를 어떻게 처리해서 어떻게 반환하는 지에 대해서 A라는 함수는 전혀 관심이 없다는 얘기다. 

추상의 대표적인 예시는 API이다. 프론트엔드에서 API 요청을 보낼 때를 생각해보자. 서버에서 API 응답을 어떻게 처리하는지, 어떤 로직을 가지고 있는지에 대해서는 프론트엔드의 관심사가 아니다. 프론트엔드에서는 API 요청을 보내고 받을 응답에 대해서만 관심이 있다. 서버에서 로직을 어떻게 바꾸든, 서버에서 사용하는 프로그래밍 언어나 프레임워크를 바꾸든 말든 프론트엔드에서는 관심이 없다. 그저 요청에 따른 응답만 잘 해주면 좋겠는 것이다. 반대로 서버 입장에서는 요청이 어디서 어떻게 올지 관심이 없다. 어디서 요청이 오든 그저 서버 입장에서는 요청을 잘 처리해서 응답을 잘 보내주기만 하면 된다.

이처럼 서버와 프론트엔드는 서로의 상황에 대해서는 관심을 가질 필요가 없다. 그저 '요청과 응답'이라는 '추상'에 관심을 가지고 있다. 이렇게 해줘야 하는 일과 결과에만 신경쓰는 것을 '추상'에 의존한다고 말한다. 프로그래밍에서 '추상'은 '인터페이스'라고도 불리는데 그래서인지, 보통 프론트엔드와 백엔드가 API 요청과 응답을 맞출 때 '인터페이스를 맞춘다'라는 표현을 사용한다고 한다.

이렇게 호출하는 모듈과 호출 당하는 모듈이 추상에 의존할 때 이를 '의존성 역전'이라고 말한다.


## 4. 구체에서 추상으로 의존의 대상이 바뀐 것 뿐인데 왜 '역전'이죠?


## 5. 의존성 주입

- 특정한 모듈에 필요한 의존성을 내부에서 가지고 있는 것이 아니라 해당 모듈을 사용하는 입장에서 주입해주는 형태로 설계하는 것을 의미한다.
- 해당 모듈에서 직접적으로 의존성을 가지고 있지 않기 때문에 모듈 내부의 코드는 전혀 건드리지 않고 모듈 외부의 일부 코드만 수정함으로서 동작을 변경할 수 있게 된다.
- 이는 프로그램의 유연성, 테스트의 용이성의 상승을 의미한다.
- 기본적으로 Class의 경우에는 constructor를 통해서, 함수의 경우에는 인자를 통해서 의존성을 주입하게 된다.
- 리액트의 컴포넌트도 함수이긴 하지만, 일반 함수와 달리, props로 데이터를 전달하는데, 그게 단방향으로만 이뤄지기 때문에 의존성을 주입하는 것이 쉽지가 않다. 그 문제를 해결하기 위한 것이 바로 ContextAPI이다.

## 6. ContextAPI

- 위에서도 말했듯이, ContextAPI를 통해 컴포넌트에 의존성을 주입할 수 있다. 
- 즉, ContextAPI는 props를 좀 더 쉽게 전달하기 위한 기술이다. 
- 간혹 전역 상태관리 기술로 알고 있는 경우도 있지만, 그건 props 전달을 최상위에서 하게되면 가능한 ContextAPI의 일부일 뿐이다. 
- 전역 뿐만 아니라, 하위 컴포넌트에 ContextAPI 프로바이더를 감써서 해당 하위 컴포넌트에만 사용할 상태를 관리할 수도 있다. 엄밀히 따지면 전역 상태관리는 아니라는 뜻이다.
- 그러면 ContextAPI를 활용해 실습을 해보자.
