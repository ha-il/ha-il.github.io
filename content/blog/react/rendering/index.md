---
title: "[리액트 렌더링] 브라우저의 렌더링 이해하기"
date: "2023-09-03T15:31:00.000Z"
description: "주소창에 google.com을 치면 일어나는 일을 설명해주세요!"
category: "react"
featuredImage: "../../../../src/images/react-256x256.png"
mobileImage: "../../../../src/images/react-512x256x2.png"
---

## 렌더링 과정을 공부하게 된 계기

최근 원티드 프리온보딩 인턴십을 진행하면서 리액트로 프로그래밍할 일이 많아졌다. 그러면서 useEffect 훅을 사용할 일이 많아졌는데, 두 번째 인자에는 보통 빈 배열을 사용하는 경우가 많았다. 하지만 그 과정에서 리액트는 나에게 경고를 띄웠다. useEffect 훅 안에서 사용하고 있는 값을 의존성 배열에 추가해야 한다고 말이다. 하지만, 내가 작성했던 코드에서 의존성 배열에 해당 값을 추가하면 무한 렌더링이 발생했다. 그래서 그냥 경고를 띄운 채로 푸쉬하고 해당 프로젝트를 Netlify로 배포하려 했으나, 프로젝트에서 발생한 useEffect 경고로 인해서 빌드에 실패히여 배포 과정에 차질이 생겼다. 배포는 겨우 진행 할 수 있었지만 이러지도 저러지도 못 하는 상황이 발생하고나니, 리액트와 브라우저의 렌더링 과정을 한 번 정리하고 가는 게 좋겠다는 판단이 들었다.

## 1. 렌더링이란?

- **렌더링(rendering)**

  HTML, CSS, 자바스크립트로 작성된 문서를 파싱하여 브라우저에 시각적으로 출력하는 것을 말한다.

  - **[파싱(Parsing)](https://ko.wikipedia.org/wiki/%EA%B5%AC%EB%AC%B8_%EB%B6%84%EC%84%9D)**

    프로그래밍 언어의 문법에 맞게 작성된 텍스트 문서를 읽어 들여 실행하기 위해 텍스트 문서의 문자열을 토큰으로 분해하고, 토튼에 문법적 의미와 구조를 반영하여 파스 트리를 생성하는 일련의 과정을 말한다. 일반적으로 파싱이 완료된 이후에는 파스 트리를 기반으로 중간 언어인 바이트코드를 생성하고 실행한다.

    - **[토큰(token)](https://ko.wikipedia.org/wiki/%EB%82%B1%EB%A7%90_%EB%B6%84%EC%84%9D)**

      문법적인 의미를 가지며, 문법적으로 더는 나눌 수 없는 코드의 기본 요소를 의미한다.

    - **[바이트코드(bytecode)](https://ko.wikipedia.org/wiki/%EB%B0%94%EC%9D%B4%ED%8A%B8%EC%BD%94%EB%93%9C)**

      가상 머신에서 실행하도록 만든 바이너리 코드를 의미한다.

## 2. 브라우저의 렌더링 과정

1. 브라우저의 요청과 서버로부터의 응답

2. HTML 파싱과 DOM 생성, CSS 파싱과 DCSSOM을 생성

3. 렌더 트리 생성

4. 자바스크립트 파싱과 실행

5. 리플로우와 리페인트

### 2.1 브라우저의 요청과 서버로부터의 응답

브라우저는 필요한 리소스를 서버에 요청하고 서버로부터 응답을 받아 브라우저에 시각적으로 렌더링한다. 그러면 브라우저는 어떻게 요청을 보내는 것일까? 바로 주소창의 URL로 요청을 보낸다. 브라우저의 주소창에 URL을 전송하면 URL의 호스트 이름이 DNS를 통해 IP 주소로 변환되고 이 IP 주소를 갖는 서버에게 요청을 전송한다.

- [URL(Uniform Resource Locator)](https://developer.mozilla.org/ko/docs/Learn/Common_questions/Web_mechanics/What_is_a_URL)

   웹에 게시된 리소스를 검색하기 위해 브라우저에서 사용하는 메커니즘.

  <img src="https://developer.mozilla.org/en-US/docs/Learn/Common_questions/Web_mechanics/What_is_a_URL/mdn-url-all.png" width="100%" alt="URL"/>
  

- [호스트 이름](https://ko.wikipedia.org/wiki/%ED%98%B8%EC%8A%A4%ED%8A%B8%EB%AA%85)

  인터넷에서 호스트 이름은 인터넷에 연결된 호스트(컴퓨터)의 이름으로, 보통 호스트의 지역 이름에 도메인 이름을 붙인 것이다. 예를 들어서 ‘ko.wikipedia.org’라는 호스트 이름에서 도메인 이름은 ‘wikipedia.org’이며 그 앞에 호스트의 지역 이름인 ‘ko’를 붙여 호스트 이름을 만든다. 이 호스트 이름은 DNS를 통해 계층적으로 IP 주소로 변환되거나, 사용자의 컴퓨터에 있는 hosts 파일에서 IP 주소를 검색하여 사용하게 된다.


- [DNS(Domain Name System)](https://ko.wikipedia.org/wiki/%EB%8F%84%EB%A9%94%EC%9D%B8_%EB%84%A4%EC%9E%84_%EC%8B%9C%EC%8A%A4%ED%85%9C)

  호스트의 도메인 이름을 호스트의 네트워크 주소로 바꾸거나 그 반대의 변환을 수행할 수 있도록 하기 위해 개발되었다.

- [IP 주소(Internet Protocol address)](https://ko.wikipedia.org/wiki/IP_%EC%A3%BC%EC%86%8C)

  컴퓨터 네트워크에서 장치들이 서로를 인식하고 통신을 하기 위해서 사용하는 특수한 번호이다.

예를 들어, 브라우저의 주소창에 https://google.com을 입력하고 엔터 키를 누르면 루트 요청이 google.com 서버로 전송된다. 루트 요청에는 명확히 리소스를 요청하는 내용이 없지만 일반적으로 서버는 루트 요청에 대해 암묵적으로 index.html을 응답하도록 기본 설정 되어있다. 즉, https://google.com은 https://google.com/index.html과 같은 요청이다.

- 루트 요청

  URI에서 스킴과 호스트만으로 구성된 URI에 의한 요청을 말한다.

위의 예시를 보면 index.html만 요청한 것과 다름이 없는데 어떻게 css와 자바스크립트 파일까지 같이 응답되는 것일까? index.html은 link 태그를 통해서 css 파일을 로드하고, script 태그를 통해서 자바스크립트 파일을 로드한다. 브라우저가 HTML을  파싱하는 과정에서 이 태그들을 만나면 HTML 파싱을 일시 중단하고 해당 리소스 파일을 서버로 요청한다.

### 2.2 HTML 파싱과 DOM 생성

자, URL로 요청을 보내서 HTML 문서를 응답 받았다. 하지만 브라우저 입장에서 HTML 문서는 그저 텍스트일 뿐이다. 브라우저가 바로 이해하기 어렵다는 의미다. HTML 문서를 렌더링하기 위해서는 브라우저가 이해할 수 있는 자료구조인 **객체**로 파싱하여 메모리에 저장해야 하는데, 이때 파싱되는 자료구조가 바로 **DOM(Document Object Model)** 이다.

서버로부터 응답받은 HTML 문서는 처음에는 바이트 형태(10010...)다. 응답된 바이트 형태의 HTML 문서를 어떤 인코딩 방식을 기준으로 문자열로 변환할 것인지 명시해야 하는데, 그 역할을 하는 코드가 `<meta chrset="UTF-8">` 이다. 브라우저는 응답 헤더에서 인코딩 방식을 확인하고 바이트 형태의 HTML 파일을 문자열로 변환한다.

문자열로 변환된 HTML 문서를 읽고 토큰으로 분해하고, 각 토큰들을 객체로 변환하여 노드들을 생성한다. 노드는 이후 DOM을 구성하는 기본 요소가 된다.

HTML 요소들은 중첩 관계를 가질 수 있고 이에 따라 부자 관계가 형성된다. 이러한 HTML 요소 간의 부자 관계를 반영하여 모든 노드들을 트리 자료구조로 구성한다. 이러한 자료구조를 DOM이라 부른다.

### 2.3 CSS 파싱과 CSSOM 생성

자, URL을 통해서 서버로 요청을 보내고 응답으로 HTML 문서를 받았고, HTML 문서를 DOM으로 생성하는 과정까지 왔다. 그러면 CSS는 대체 언제 요청하고 언제 파싱하는 것일까?

HTML 요소에는 Link라는 태그가 있다. 브라우저의 렌더링 엔진이 HTML을 DOM으로 생성하는 과정에서 Link 태그를 만나게 되면 DOM 생성을 일시 중단한다. 그리고 해당 Link 태그의 href 속성에 지정된 CSS 파일을 서버에 요청하고 응답 받은 CSS 파일을 HTMl과 동일한 파싱 과정을 거치며 해석하여 CSSOM을 생성한다.

CSS 파싱을 완료하면 HTML 파싱이 중단된 지점부터 다시 HTML을 파싱하기 시작하여 DOM 생성을 재개한다.

### 2.4 렌더 트리 생성

자, DOM과 CSSOM 생성 과정까지 왔다. HTML을 파싱하여 DOM을 생성하는 과정 중에서 css 파일이 지정된 link 태그 만나면 DOM 생성을 일시 중단하고 CSSOM을 생성한다. CSSOM 생성이 완료되면 다시 DOM을 생성한다. 이렇게 생성된 DOM과 CSSOM은 렌더 트리로 결합된다.

렌더 트리는 렌더링을 위한 트리 구조의 자료구조다. 그래서 브라우저 화면에 렌더링 될 노드만 포함되어 있다. 예를 들어 link나 script 태그, 또는 CSS에서 display:none 처리된 노드들은 포함되지 않는다. (CSS 차원에서 뭔가를 숨겨야 한다면 display:none을 사용하는 것이 렌더링 성능에는 더 좋을 수 있겠다.)

완성된 렌더 트리는 각 HTML 요소의 레이아웃을 계산하는 데 사용되며 브라우저 화면에 픽셀을 렌더링하는 페인팅 처리에 입력된다.

이 과정까지 거치면 일단 1차적인 렌더링은 완료된 것이다.


### 2.5 자바스크립트 파싱과 실행

브라우저의 렌더링 엔진이 HTML을 DOM으로 파싱하는 과정에서 css 파일을 불러오는 link 태그를 만나면 HTML 파싱을 중단한다고 위에서 언급했다. link 태그와 마찬가지로 HTML 파싱을 일시 중단할 수 있는 HTML 요소가 하나 더 있는데 바로 script 태그다.

렌더링 엔진이 HTML을 DOM으로 파싱하다가 자바스크립트 파일을 로드하는 script 태그를 만나면 DOM 파싱을 일시 중단한다. 그리고 script 태그의 src 속성에 정의된 자바스크립트 파일을 서버에 요청하고 자바스크립트 파일을 응답받는데, 이때 자바스크립트 코드를 파싱하기 위해 제어권을 자바스크립트 엔진에 넘긴다.

자바스크립트 엔진은 자바스크립트 코드를 토큰으로 분해한다. 그리고 토큰들의 집합을 구문 분석하여 AST(Abstract Syntax Tree)를 생성한다. AST를 기반으로 인터프리터가 실행할 수 있는 중간 코드인 바이트코드를 생성하여 실행한다.

자바스크립트 파싱과 실행이 종료되면 자바스크립트 엔진에 있던 제어권을 다시 렌더링 엔진으로 넘기고, HTML 파싱이 중단된 지점부터 DOM 생성을 재개한다.

여기서 주의해야 할 점은 렌더링 엔진과 자바스크립트 엔진이 각각 존재한다고 해서 두 엔진이 병렬적으로 돌아간다는 의미는 아니라는 것이다. 자바스크립트 엔진에 제어권이 넘어갈 경우 렌더링 엔진의 HTML 파싱은 중단된다. 즉, script태그가 다른 html 요소에 비해 상위에 작성되어 있으면, 자바스크립트를 파싱하느라 DOM 생성이 지연되기 때문에, 사용자 입장에서는 렌더링이 늦어지는 것처럼 느껴진다. 흔히 HTML을 가르치는 강의에서 link 태그는 위에, script 태그는 아래에 작성하라고 하는데, 그게 이런 이유 때문이다.


### 2.6 리렌더링

지금까지 살펴 본 렌더링 과정은 당연히 다시 일어날 수 있다. 애초에 리렌더링이 불가능하다면 사용자는 웹 사이트에서 아무런 상호작용도 할 수 없을테니 말이다. 다만 아무 때나 리렌더링이 이뤄지는 것은 아니다. 아래와 같은 경우 리렌더링이 발생한다.

- 자바스크립트에 의한 노드 추가 또는 삭제
- 브라우저 창의 리사이징에 의한 뷰포트 크기 변경
- HTML 요소의 레이아웃에 변경을 발생시키는 스타일의 변경

DOM은 DOM을 조작할 수 있는 DOM API를 제공한다. DOM API는 자바스크립트 코드를 통해 사용할 수 있다. 자바스크립트 코드에 DOM API가 사용된 경우 DOM이 변경되는데, 이때 변경된 DOM은 다시 렌더트리로 결합되고, 새롭게 결합된 렌더 트리를 기반으로 레이아웃과 페인트 과정을 거쳐 브라우저의 화면에 다시 렌더링 한다. 이 과정을 리플로우, 리페인트라 한다.