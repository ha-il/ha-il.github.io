---
title: "[리액트 렌더링] 브라우저의 렌더링 이해하기"
date: "2023-09-03T15:31:00.000Z"
description: "주소창에 google.com을 치면 일어나는 일을 설명해주세요!"
category: "react"
featuredImage: "../../../../src/images/react-256x256.png"
mobileImage: "../../../../src/images/react-512x256x2.png"
---

## 렌더링 과정을 공부하게 된 계기

최근 원티드 프리온보딩 인턴십을 진행하면서 리액트로 프로그래밍할 일이 많아졌다. 그러면서 useEffect 훅을 사용할 일이 많아졌는데 그 과정에서 리액트는 나에게 경고 많이 띄웠다. 자주 만났던 경고는 useEffect 훅 안에서 사용하고 있는 값을 의존성 배열에 추가해야 한다는 경고였다. 하지만, 내가 작성했던 코드에서 의존성 배열에 해당 값을 추가하면 무한 렌더링이 발생했다. 그래서 그냥 경고를 띄운 채로 푸쉬하고 해당 프로젝트를 Netlify로 배포하려 했으나, 프로젝트에서 발생한 useEffect 경고로 인해서 빌드에 실패히여 배포 과정에 차질이 생겼다. 배포는 겨우 진행 할 수 있었지만 이러지도 저러지도 못 하는 상황이 발생하고나니, 리액트와 브라우저의 렌더링 과정을 한 번 정리하고 가는 게 좋겠다는 판단이 들었다.

## 1. 렌더링이란? - 관련 용어 정리

브라우저에서 **렌더링(rendering)** 이란 **HTML, CSS, 자바스크립트로 작성된 문서를 파싱하여 브라우저에 시각적으로 출력하는 것을 말한다.**

그렇다면 파싱은 무엇일까? **[파싱(Parsing)](https://ko.wikipedia.org/wiki/%EA%B5%AC%EB%AC%B8_%EB%B6%84%EC%84%9D)** 은 프로그래밍 언어의 문법에 맞게 작성된 텍스트 문서(우리의 경우 HTML, CSS, 자바스크립트)를 읽어 들여 실행하기 위해 텍스트 문서의 문자열을 토큰으로 분해하고, 토튼에 문법적 의미와 구조를 반영하여 파스 트리를 생성하는 일련의 과정을 말한다. 일반적으로 파싱이 완료된 이후에는 파스 트리를 기반으로 중간 언어인 바이트코드를 생성하고 실행한다.

그렇다면 토큰과 바이트코드는 무엇일까? **[토큰(token)](https://ko.wikipedia.org/wiki/%EB%82%B1%EB%A7%90_%EB%B6%84%EC%84%9D)** 은 문법적인 의미를 가지며, 문법적으로 더는 나눌 수 없는 코드의 기본 요소를 의미한다. **[바이트코드(bytecode)](https://ko.wikipedia.org/wiki/%EB%B0%94%EC%9D%B4%ED%8A%B8%EC%BD%94%EB%93%9C)** 가상 머신에서 실행하도록 만든 바이너리 코드를 의미한다. 쉽게 말하면 10010111과 같이 0과 1로 이루어진 코드를 말한다.

초반부터 어려운 용어가 마구 튀어나오는데, 쉽게 말하면 이렇게 정리할 수 있을 것 같다.

브라우저의 렌더링이란, HTML, CSS, 자바스크립트 문서를 가지고 브라우저 화면에 시각적으로 출력하는 것을 말한다. 그 문서 그대로는 브라우저가 해석할 수 없기 때문에 일종의 변환 과정이 필요한데 그 과정이 파싱이다. 그 파싱이라는 변환 과정은 HTML, CSS, 자바스크립트 문서를 토큰이라는 최소 단위까지 분해하고, 문법적으로 최대한 분해된 토큰을 기준으로 파스 트리를 만들어 브라우저가 이해할 수 있는 형태로 만든다. 브라우저는 그것을 해석하여 시각적으로 출력한다.

즉, 브라우저의 렌더링 과정은 브라우저에서 HTML, CSS, 자바스크립트 문서를 불러들여서 브라우저가 이해할 수 있는 형태로 변환한 다음, 그 변환 결과물을 브라우저 화면에 시각적으로 출력하는 과정이라고 말할 수 있겠다. 물론 변환 결과물에 변화가 생기면 이 렌더링 과정은 다시 발생할 수 있다.

## 2. 브라우저의 렌더링 과정

위에서 정리했던 내용을 기반으로 브라우저 렌더링 과정을 나눠보면 아래와 같이 나눌 수 있겠다.

1. HTML, CSS, 자바스크립트 문서를 불러들인다.
2. 불러들인 문서를 변환한다.
3. 변환한 결과물을 시각적으로 출력한다.
4. 결과물에 변화를 준다.
5. 다시 렌더링한다.

이 과정을 조금 더 자세하게 표현하면 아래와 같이 표현할 수 있다.

1. **브라우저의 요청과 서버로부터의 응답**
2. **HTML 파싱과 DOM 생성**
3. **CSS 파싱과 CSSOM 생성**
4. **렌더 트리 생성과 브라우저의 출력**
5. **자바스크립트 파싱과 실행**
6. **리렌더링**

이 순서대로 브라우저의 렌더링 과정을 자세하게 살펴보자.

### 2.1 브라우저의 요청과 서버로부터의 응답

브라우저는 필요한 리소스를 서버에 요청하고 서버로부터 응답을 받아 브라우저에 시각적으로 렌더링한다. 그러면 브라우저는 어떻게 요청을 보내는 것일까? 바로 주소창의 URL로 요청을 보낸다. **브라우저의 주소창에 URL을 전송하면 URL의 호스트 이름이 DNS를 통해 IP 주소로 변환되고 이 IP 주소를 갖는 서버에게 요청을 전송한다.**

- [**URL(Uniform Resource Locator)**](https://developer.mozilla.org/ko/docs/Learn/Common_questions/Web_mechanics/What_is_a_URL)

   웹에 게시된 리소스를 검색하기 위해 브라우저에서 사용하는 메커니즘.

  <img src="https://developer.mozilla.org/en-US/docs/Learn/Common_questions/Web_mechanics/What_is_a_URL/mdn-url-all.png" width="100%" alt="URL"/>
  

- [**호스트 이름**](https://ko.wikipedia.org/wiki/%ED%98%B8%EC%8A%A4%ED%8A%B8%EB%AA%85)

  인터넷에서 호스트 이름은 인터넷에 연결된 호스트(컴퓨터)의 이름으로, 보통 호스트의 지역 이름에 도메인 이름을 붙인 것이다. 예를 들어서 ‘ko.wikipedia.org’라는 호스트 이름에서 도메인 이름은 ‘wikipedia.org’이며 그 앞에 호스트의 지역 이름인 ‘ko’를 붙여 호스트 이름을 만든다. 이 호스트 이름은 DNS를 통해 계층적으로 IP 주소로 변환되거나, 사용자의 컴퓨터에 있는 hosts 파일에서 IP 주소를 검색하여 사용하게 된다.


- [**DNS(Domain Name System)**](https://ko.wikipedia.org/wiki/%EB%8F%84%EB%A9%94%EC%9D%B8_%EB%84%A4%EC%9E%84_%EC%8B%9C%EC%8A%A4%ED%85%9C)

  호스트의 도메인 이름을 호스트의 네트워크 주소로 바꾸거나 그 반대의 변환을 수행할 수 있도록 하기 위해 개발되었다.

오케이, 브라우저의 주소창에 URL을 입력하면 파일을 요청한다는 것까지는 알겠다. 하지만 나는 https://google.com 은 입력해 본적이 있지만, https://google.com/index.html 이나 https://google.com/style.css 같은 것은 입력한 적이 없다. 아무런 파일도 명시한 적이 없는데, 어떻게 브라우저는 렌더링에 필요한 파일을 요청해서 받아오는 것일까? 이는 https://google.com 만 입력하면 루트 요청이 전송되기 때문이다.

- **루트 요청**

  URI에서 스킴과 호스트만으로 구성된 URI에 의한 요청을 말한다.

예를 들어, 브라우저의 주소창에 https://google.com을 입력하고 엔터 키를 누르면 루트 요청이 google.com 서버로 전송된다. 루트 요청에는 명확히 리소스를 요청하는 내용이 없지만 일반적으로 서버는 루트 요청에 대해 암묵적으로 index.html을 응답하도록 기본 설정 되어있다. 즉, https://google.com은 https://google.com/index.html과 같은 요청이다.

위의 예시를 보면 index.html만 요청한 것과 다름이 없는데 어떻게 css와 자바스크립트 파일까지 같이 응답되는 것일까? index.html은 link 태그를 통해서 css 파일을 로드하고, script 태그를 통해서 자바스크립트 파일을 로드한다. **브라우저가 HTML을 파싱하는 과정에서 link 또는 script 태그를 만나면 HTML 파싱을 일시 중단하고 해당 리소스 파일을 서버로 요청한다.**

### 2.2 HTML 파싱과 DOM 생성

자, URL로 요청을 보내서 HTML 문서를 응답 받았다. 하지만 브라우저 입장에서 HTML 문서는 그저 텍스트일 뿐이다. 브라우저가 바로 이해하기 어렵다는 의미다. HTML 문서를 렌더링하기 위해서는 브라우저가 이해할 수 있는 자료구조인 **객체**로 파싱하여 메모리에 저장해야 하는데, 이때 파싱되는 자료구조가 바로 **DOM(Document Object Model)** 이다.

서버로부터 응답받은 HTML 문서는 처음에는 바이트 형태다. 응답된 바이트 형태의 HTML 문서를 어떤 인코딩 방식을 기준으로 문자열로 변환할 것인지 명시해야 하는데, 그 역할을 하는 코드가 `<meta chrset="UTF-8">` 이다. 브라우저는 응답 헤더에서 인코딩 방식을 확인하고 바이트 형태의 HTML 파일을 문자열로 변환한다.

문자열로 변환된 HTML 문서를 읽고 토큰으로 분해하고, 각 토큰들을 객체로 변환하여 노드들을 생성한다. 노드는 이후 DOM을 구성하는 기본 요소가 된다.

HTML 요소들은 중첩 관계를 가질 수 있고 이에 따라 부자 관계가 형성된다. 이러한 HTML 요소 간의 부자 관계를 반영하여 모든 노드들을 트리 자료구조로 구성한다. 이러한 자료구조를 DOM이라 부른다.

HTML 파싱과정을 정리하면,

**바이트코드로 응답받음 → 문자열로 변환 → 토큰으로 분해 → 객체로 변환 후 노드 생성 → 노드로 DOM 생성**

이렇게 정리할 수 있겠다.

### 2.3 CSS 파싱과 CSSOM 생성

자, URL을 통해서 서버로 요청을 보내고 응답으로 HTML 문서를 받았고, HTML 문서를 DOM으로 생성하는 과정까지 왔다. 그러면 CSS는 대체 언제 요청하고 언제 파싱하는 것일까?

HTML 요소에는 Link라는 태그가 있다. 브라우저의 렌더링 엔진이 HTML을 DOM으로 생성하는 과정에서 Link 태그를 만나게 되면 DOM 생성을 일시 중단한다. 그리고 해당 **Link 태그의 href 속성에 지정된 CSS 파일을 서버에 요청하고 응답 받은 CSS 파일을 HTMl과 동일한 파싱 과정을 거치며 해석하여 CSSOM을 생성한다.**

CSS 파싱을 완료하면 HTML 파싱이 중단된 지점부터 다시 HTML을 파싱하기 시작하여 DOM 생성을 재개한다.

### 2.4 렌더 트리 생성과 브라우저의 출력

자, DOM과 CSSOM 생성 과정까지 왔다. HTML을 파싱하여 DOM을 생성하는 과정 중에서 css 파일이 지정된 link 태그 만나면 DOM 생성을 일시 중단하고 CSSOM을 생성한다. CSSOM 생성이 완료되면 다시 DOM을 생성한다. 이렇게 생성된 **DOM과 CSSOM은 렌더 트리로 결합**된다.

렌더 트리는 렌더링을 위한 트리 구조의 자료구조다. 그래서 **브라우저 화면에 렌더링 될 노드만 포함**되어 있다. 예를 들어 link나 script 태그, 또는 CSS에서 display:none 처리된 노드들은 포함되지 않는다. (CSS 차원에서 뭔가를 숨겨야 한다면 display:none을 사용하는 것이 렌더링 성능에는 더 좋을 수 있겠다.)

**완성된 렌더 트리는 각 HTML 요소의 레이아웃을 계산하는 데 사용되며 브라우저 화면에 픽셀을 렌더링하는 페인팅 처리에 입력된다.**

이 과정까지 거치면 일단 1차적인 렌더링은 완료된 것이다.


### 2.5 자바스크립트 파싱과 실행

브라우저의 렌더링 엔진이 HTML을 DOM으로 파싱하는 과정에서 css 파일을 불러오는 link 태그를 만나면 HTML 파싱을 중단한다고 위에서 언급했다. link 태그와 마찬가지로 HTML 파싱을 일시 중단할 수 있는 HTML 요소가 하나 더 있는데 바로 script 태그다.

**렌더링 엔진이 HTML을 DOM으로 파싱하다가 자바스크립트 파일을 로드하는 script 태그를 만나면 DOM 파싱을 일시 중단한다.** 그리고 script 태그의 src 속성에 정의된 자바스크립트 파일을 서버에 요청하고 자바스크립트 파일을 응답받는데, **이때 자바스크립트 코드를 파싱하기 위해 제어권을 자바스크립트 엔진에 넘긴다.**

자바스크립트 엔진은 자바스크립트 코드를 토큰으로 분해한다. 그리고 토큰들의 집합을 구문 분석하여 AST(Abstract Syntax Tree)를 생성한다. AST를 기반으로 인터프리터가 실행할 수 있는 중간 코드인 바이트코드를 생성하여 실행한다.

자바스크립트 파싱과 실행이 종료되면 자바스크립트 엔진에 있던 제어권을 다시 렌더링 엔진으로 넘기고, HTML 파싱이 중단된 지점부터 DOM 생성을 재개한다.

**여기서 주의해야 할 점은 렌더링 엔진과 자바스크립트 엔진이 각각 존재한다고 해서 두 엔진이 병렬적으로 돌아간다는 의미는 아니라는 것이다.** 자바스크립트 엔진에 제어권이 넘어갈 경우 렌더링 엔진의 HTML 파싱은 중단된다. 즉, script태그가 다른 html 요소에 비해 상위에 작성되어 있으면, 자바스크립트를 파싱하느라 DOM 생성이 지연되기 때문에, 사용자 입장에서는 렌더링이 늦어지는 것처럼 느껴진다. 흔히 HTML을 가르치는 강의에서 link 태그는 위에, script 태그는 아래에 작성하라고 하는데, 그게 이런 이유 때문이다.

참고: 자바스크립트 파싱으로 인해 DOM 생성이 중단되는 문제를 해결하기 위한 script 태그의 속성이 두 가지 있다. 바로 async와 defer다. 자세한 내용은 [MDN - script: 스크립트 요소](https://developer.mozilla.org/ko/docs/Web/HTML/Element/script#%ED%8A%B9%EC%84%B1)를 참고하길 바란다.

### 2.6 리렌더링

지금까지 살펴 본 렌더링 과정은 당연히 다시 일어날 수 있다. 애초에 리렌더링이 불가능하다면 사용자는 웹 사이트에서 아무런 상호작용도 할 수 없을 것이다. 다만 아무 때나 리렌더링이 이뤄지는 것은 아니다. 아래와 같은 경우 리렌더링이 발생한다.

- **자바스크립트에 의한 노드 추가 또는 삭제**
- **브라우저 창의 리사이징에 의한 뷰포트 크기 변경**
- **HTML 요소의 레이아웃에 변경을 발생시키는 스타일의 변경**

DOM은 DOM을 조작할 수 있는 DOM API를 제공한다. DOM API는 자바스크립트 코드를 통해 사용할 수 있다. 자바스크립트 코드에 DOM API가 사용된 경우 DOM이 변경되는데, 이때 변경된 DOM은 다시 렌더트리로 결합되고, 새롭게 결합된 렌더 트리를 기반으로 레이아웃과 페인트 과정을 거쳐 브라우저의 화면에 다시 렌더링 한다. 이 과정을 리플로우, 리페인트라 한다.

렌더 트리가 생성되면 레이아웃을 계산하는 데 사용되고, 브라우저 화면에 픽셀을 렌더링하는 페인팅 처리에 사용된다. **레이아웃을 다시 계산하는 것이 리플로우, 페팅팅 처리를 다시 하는 것이 리페인트이다.**

## 3. 리액트의 등장 이유

바닐라 자바스크립트를 이용해서 DOM에 직접 접근하고 수정하는 방식, 그리고 이것을 최적화 하는 방식은 꽤나 골치 아픈 일이다. 접근할 DOM 요소를 지정하고, 그 요소를 어떻게 조작할 것인지 일일이 지정해줘야 한다. 다른 말로 표현하면 명령형으로 코딩해야 한다는 것이다. 그리고 직관적이지 않다. 자바스크립트로 DOM 노드를 만들거나 수정할 수 있지만 결국 표현되는 것은 html 요소이다. html요소를 자바스크립트 코드만 보고 떠올리는 것은 직관적이지 않다.

이렇게 바닐라 자바스크립트로 프론트엔드 개발을 하는 것에는 여러 불편함이 있었다. DOM을 찾아내고 조작하고 렌더링하는 과정을 간소화하고 개발자는 UI에만 집중할 수 있다면 얼마나 좋을까? 렌더링 될 UI를 선언하는 것에만 개발자가 집중할 수 있다면 더 많은 UI를 빠르게 개발할 수 있지 않을까? 이러한 생각으로 등장한 라이브러리 중 가장 유명한 라이브러리가 **React**이다.

렌더링은 React가 다 해주고 개발자는 UI 설계에만 집중할 수 있다. 말만 들어도 너무 좋지만 이 또한 만능은 아니다. React 내부에서 처리해주는 렌더링을 최적화해야 하는 상황이 발생하곤 한다. 이를 위해서는 React 내부에서 렌더링이 언제 발생하고 어떤 과정을 거쳐서 이루어지는 지를 이해하고 있어야 한다. 따라서 다음 글에서는 리액트의 렌더링에 대해서 알아보자.

## 참고자료

- 모던 자바스크립트 Deep Dive: 자바스크립트의 기본 개념과 동작 원리 
  - by 이웅모 (출처: 위키북스, 2020), p.660-676 “38장 브라우저의 렌더링 과정”
  - [도서 구매 링크(교보문고)](https://product.kyobobook.co.kr/detail/S000001766445)

- MDN Web Docs: 웹페이지를 표시한다는 것: 브라우저는 어떻게 동작하는가
  - by [MDN contributors.](https://developer.mozilla.org/ko/docs/Web/Performance/How_browsers_work/contributors.txt)
  - accessed September 4
  - [문서 링크](https://developer.mozilla.org/ko/docs/Web/Performance/How_browsers_work) 


