{"componentChunkName":"component---src-templates-blog-post-js","path":"/typescript/types/","result":{"data":{"site":{"siteMetadata":{"title":"하일의 작업실"}},"markdownRemark":{"id":"f2d343a0-5d77-5f5b-a96d-6377a5421862","excerpt":"1. 타입 추론 타입 추론이란 타입스크립트가 코드를 해석하여 적절한 타입을 정의하는 동작을 의미한다. 타입 추론이 가능하기 때문에 타입 지정을 생략할 수 있는 코드에서는 생략이 가능하다. 이는 코드를 간결하게 해주어 코드의 가독성을 높이는 효과가 있다. 1.…","html":"<h2>1. 타입 추론</h2>\n<p>타입 추론이란 타입스크립트가 코드를 해석하여 적절한 타입을 정의하는 동작을 의미한다. 타입 추론이 가능하기 때문에 타입 지정을 생략할 수 있는 코드에서는 생략이 가능하다. 이는 코드를 간결하게 해주어 코드의 가독성을 높이는 효과가 있다.</p>\n<h3>1.1 변수의 타입 추론</h3>\n<p>변수 타입은 선언하는 시점에 할당된 값을 기반으로 추론된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">let</span> stringVar <span class=\"token operator\">=</span> <span class=\"token string\">'Hello, world!'</span> <span class=\"token comment\">// let stringVar: string</span>\n<span class=\"token keyword\">let</span> numberVar <span class=\"token operator\">=</span> <span class=\"token number\">123</span> <span class=\"token comment\">// let numberVar: number</span>\n<span class=\"token keyword\">let</span> booleanVar <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span> <span class=\"token comment\">// let booleanVar: boolean</span>\n\n<span class=\"token keyword\">let</span> whatAmI <span class=\"token comment\">// let whatAmI: any</span>\nwhatAmI <span class=\"token operator\">=</span> <span class=\"token number\">123</span> <span class=\"token comment\">// let whatAmI: any</span></code></pre></div>\n<p><code class=\"language-text\">whatAmI</code>변수의 경우 선언은 했지만 값은 할당하지 않았다. 따라서 해당 변수의 타입은 any이다. 이후에 값을 할당하더라도 타입은 any이다. 타입스크립트 입장에서는 선언 후에 어떤 값이 할당될 지 알 수 없기 때문이다.</p>\n<h3>1.2 함수의 타입 추론</h3>\n<ul>\n<li><strong>반환 값 타입 추론</strong></li>\n</ul>\n<p>타입스크립트는 함수의 파라미터와 내부 동작에 따라서 함수의 반환값 타입을 추론할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// sum 함수의 반환 값 타입을 지정해주지 않았다. </span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">sum</span><span class=\"token punctuation\">(</span>a<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">,</span> b<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> a <span class=\"token operator\">+</span> b\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 타입 추론으로 인해 result는 number로 추론된다.</span>\n<span class=\"token keyword\">let</span> result <span class=\"token operator\">=</span> <span class=\"token function\">sum</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// let result: number</span></code></pre></div>\n<ul>\n<li><strong>파라미터 타입 추론</strong></li>\n</ul>\n<p>파라미터의 경우 타입을 지정하는 경우가 많지만, 기본값을 설정한 경우 기본값에 따라서 파라미터 타입이 추론된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">sum</span><span class=\"token punctuation\">(</span>a<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">,</span> b <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// (parameter) b: number</span>\n  <span class=\"token keyword\">return</span> a <span class=\"token operator\">+</span> b\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">let</span> result <span class=\"token operator\">=</span> <span class=\"token function\">sum</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// let result: number</span>\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span> <span class=\"token comment\">// 5</span></code></pre></div>\n<h3>1.3 함수와 제네릭의 추론</h3>\n<p>제네릭 함수를 사용할 때 제네릭으로 특정 타입을 넘겨주지 않더라도, 인자로 받은 값을 기준으로 타입을 추론한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">firstElement</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>Type<span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>arr<span class=\"token operator\">:</span> Type<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Type <span class=\"token operator\">|</span> <span class=\"token keyword\">undefined</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">typeof</span> arr<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">return</span> arr<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 제네릭으로 아무것도 넘겨주지 않았지만 함수는 동작한다.</span>\n<span class=\"token function\">firstElement</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">'a'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'c'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//  \"a\",  \"string\" </span>\n<span class=\"token function\">firstElement</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 1,  \"number\" </span>\n<span class=\"token function\">firstElement</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// true,  \"boolean\" </span>\n</code></pre></div>\n<h3>1.4 인터페이스와 제네릭의 추론</h3>\n<p>인터페이스에 제네릭을 사용할 때도, 제네릭으로 넘겨 받은 타입을 기준으로 타입을 추론할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">Message<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span> <span class=\"token punctuation\">{</span>\n  text<span class=\"token operator\">:</span> <span class=\"token constant\">T</span>\n  isFocused<span class=\"token operator\">:</span> <span class=\"token builtin\">boolean</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 제네릭으로 string 타입을 넘겼으므로 text 속성의 타입은 string으로 추론된다.</span>\n<span class=\"token keyword\">let</span> message<span class=\"token operator\">:</span> Message<span class=\"token operator\">&lt;</span><span class=\"token builtin\">string</span><span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// (property) Message&lt;string>.text: string</span>\n  <span class=\"token comment\">// (property) Message&lt;string>.text: string</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>인터페이스의 상속과 제네릭이 얽혀있는 경우에도 타입 추론이 가능하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">Message<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span> <span class=\"token punctuation\">{</span>\n  text<span class=\"token operator\">:</span> <span class=\"token constant\">T</span>\n  isFocused<span class=\"token operator\">:</span> <span class=\"token builtin\">boolean</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">ErrorMessage<span class=\"token operator\">&lt;</span><span class=\"token constant\">K</span><span class=\"token operator\">></span></span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Message<span class=\"token operator\">&lt;</span><span class=\"token constant\">K</span><span class=\"token operator\">></span></span> <span class=\"token punctuation\">{</span>\n  status<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">let</span> errorMessage<span class=\"token operator\">:</span> ErrorMessage<span class=\"token operator\">&lt;</span><span class=\"token builtin\">string</span><span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// (property) Message&lt;string>.text: string</span>\n  <span class=\"token comment\">// (property) Message&lt;T>.isFocused: boolean</span>\n  <span class=\"token comment\">// (property) ErrorMessage&lt;K>.status: number</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위 예시를 보면 <code class=\"language-text\">ErrorMessage</code> 인터페이스에 제네릭으로 string 타입을 넘겨줬지만, 정작 <code class=\"language-text\">ErrorMessage</code>에서는 넘겨 받은 제네릭을 사용하고 있지 않다. 하지만 넘겨 받은 제네릭을 부모 인터페이스인 <code class=\"language-text\">Message</code>로 넘겨 주고 있고, 이로 인해서 <code class=\"language-text\">errorMessage</code>의 <code class=\"language-text\">text</code> 속성은 string 타입으로 추론되고 있다.</p>\n<h2>2. 타입 단언(type assertion)</h2>\n<p>타입 단언은 타입스크립트의 타입 추론에 기대지 않고 개발자가 직접 타입을 명시하여 해당 타입으로 강제하는 것을 의미한다. 이미 운영되고 있는 자바스크립트 애플리케이션에 타입스크립트를 적용할 때 사용할 수 있다. 아래 예시의 <code class=\"language-text\">oldObj</code>를 기존에 존재하던 자바스크립트 객체라고 생각하면서 예시를 보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> oldObj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  id<span class=\"token operator\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span>\n\noldObj<span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> <span class=\"token string\">'업데이트'</span> <span class=\"token comment\">// 에러 발생: Property 'value' does not exist on type '{ id: number; }'</span></code></pre></div>\n<p>타입스크립트 입장에서 <code class=\"language-text\">value</code>라는 속성은 <code class=\"language-text\">oldObj</code>에 존재하지 않기 때문에 함부로 추가할 수 없어서 에러가 발생한다. 하지만 반드시 <code class=\"language-text\">value</code>를 추가해야 한다면 <code class=\"language-text\">as</code>라는 키워드를 사용하여 타입 단언을 하면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">MyObject</span> <span class=\"token punctuation\">{</span>\n  id<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span>\n  value<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> oldObj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  id<span class=\"token operator\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">as</span> MyObject\n\noldObj<span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> <span class=\"token string\">'업데이트'</span> <span class=\"token comment\">// 에러가 발생하지 않는다.</span></code></pre></div>\n<p>또 다른 예시로는 <code class=\"language-text\">document.getElementById</code>가 있다. 코드상에서 <code class=\"language-text\">document.getElementById</code>가 사용되는 경우, 타입스크립트는 이때 HTMLElement 중에 무언가가 반환된다는 것만을 알 수 있는 반면에, 개발자는 페이지 상에서 사용되는 ID로는 언제나 HTMLCanvasElement가 반환된다는 사실을 이미 알고 있다. 이런 경우 타입 단언을 사용하면 타입을 좀 더 구체적으로 명시할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> myCanvas <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"main_canvas\"</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> HTMLCanvasElement<span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 꺾쇠괄호를 사용하는 것 또한 (코드가 .tsx 파일이 아닌 경우) 가능하며, 이는 동일한 의미를 가진다.</span>\n<span class=\"token keyword\">const</span> myCanvas <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span>HTMLCanvasElement<span class=\"token operator\">></span>document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"main_canvas\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3>2.1 as를 사용할 수 있는 대상</h3>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// 원시값</span>\n<span class=\"token keyword\">let</span> me <span class=\"token operator\">=</span> <span class=\"token string\">'hail'</span> <span class=\"token keyword\">as</span> <span class=\"token builtin\">string</span>\n\n<span class=\"token comment\">// 객체</span>\n<span class=\"token keyword\">let</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> <span class=\"token keyword\">as</span> <span class=\"token punctuation\">{</span> id<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 함수의 호출 결과</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">justReturn</span><span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> x\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">let</span> value <span class=\"token operator\">=</span> <span class=\"token function\">justReturn</span><span class=\"token punctuation\">(</span><span class=\"token number\">123</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> <span class=\"token builtin\">number</span></code></pre></div>\n<h3>2.2 타입 단언 사용 시 주의 사항</h3>\n<ul>\n<li><strong>호환되지 않는 데이터 타입으로는 단언할 수 없다.</strong></li>\n</ul>\n<p>예를 들자면, string 값을 number로 단언할 수는 없다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">let</span> value <span class=\"token operator\">=</span> <span class=\"token string\">\"1004\"</span> <span class=\"token keyword\">as</span> <span class=\"token builtin\">number</span> <span class=\"token comment\">// 에러 발생</span>\n<span class=\"token comment\">/*\nConversion of type 'string' to type 'number' may be a mistake because neither type sufficiently overlaps with the other. \nIf this was intentional, convert the expression to 'unknown' first.\n*/</span></code></pre></div>\n<ul>\n<li><strong>타입 단언으로 타입 에러를 해결할 수 있지만, 실행 에러는 방지하지 못 한다.</strong></li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">User</span> <span class=\"token punctuation\">{</span>\n  id<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span>\n  name<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">getUser</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> name<span class=\"token operator\">:</span> <span class=\"token string\">'하일'</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// getUser가 반환하는 값이 User 인터페이스와 일치한다고 단언했다.</span>\n<span class=\"token keyword\">let</span> hail <span class=\"token operator\">=</span> <span class=\"token function\">getUser</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> User\n\n<span class=\"token comment\">// 하지만 단언과 달리 hail이라는 객체에 id라는 속성은 없다.</span>\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>hail<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">)</span> <span class=\"token comment\">// undefined</span></code></pre></div>\n<p>위 예시의 <code class=\"language-text\">getUser</code> 함수의 반환 값은 <code class=\"language-text\">User</code> 인터페이스와 일치하지 않는다. 하지만 <code class=\"language-text\">as</code>를 사용해서 <code class=\"language-text\">User</code> 인터페이스와 일치한다고 단언했다. 이렇게 작성하면 VSCode 상에서는 에러가 발생하지 않는다. 하지만 단언과 달리 <code class=\"language-text\">hail.id</code>는 존재하지 않기 때문에, <code class=\"language-text\">hail.id</code>를 함수의 인자로 사용할 경우 실행 에러가 발생할 확률이 높다.</p>\n<p>타입 단언은 타입 에러 해결을 간편하게 해주지만 실행 에러를 방지하지 못 하기 때문에 남용해서는 안 된다. 타입 단언보다 타입 추론에 의존하는 것이 더 안전하다.</p>\n<h3>2.3 null 아님 보장 연산자(non null assertion)</h3>\n<p>'null 아님 보장 연산자'는 null 타입을 체크할 때 유용하게 쓰는 연산자다. 프론트엔드 프로그래밍을 하다보면, 함수에 특정한 값을 인자로 전달하려고 했지만 어떠한 이유로 null 값이 전달되는 경우가 종종 있다. 따라서 함수에 null 값이 들어왔을 때 대처하는 코드를 작성해야 하는 경우가 있다. 아래 예시를 보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">BaseballPlayer</span> <span class=\"token punctuation\">{</span>\n    backNumber<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span>\n    name<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// null 값이 들어올 수 있는 함수라 가정하고 파라미터의 타입을 유니언 타입으로 지정했다.</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">IntroducePlayer</span><span class=\"token punctuation\">(</span>player<span class=\"token operator\">:</span> BaseballPlayer <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 에러 발생: 'player' is possibly 'null'</span>\n  <span class=\"token keyword\">return</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>player<span class=\"token punctuation\">.</span>backNumber<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">번 </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>player<span class=\"token punctuation\">.</span>name<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\"> 선수를 소개합니다!</span><span class=\"token template-punctuation string\">`</span></span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>타입스크립트 입장에서는 <code class=\"language-text\">player</code>가 null이라면 <code class=\"language-text\">backNumber</code>와 <code class=\"language-text\">name</code>이라는 속성은 존재하지 않기 때문에 에러를 발생시킨 것이다. if문을 사용해서 null을 체크하는 로직을 넣어도 되지만, 파라미터가 null이 아니라는 확신이 있다면 null 아님 보장 연산자인 <code class=\"language-text\">!</code>를 사용할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">IntroducePlayer</span><span class=\"token punctuation\">(</span>player<span class=\"token operator\">:</span> BaseballPlayer <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 에러가 발생하지 않는다.</span>\n  <span class=\"token keyword\">return</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>player<span class=\"token operator\">!</span><span class=\"token punctuation\">.</span>backNumber<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">번 </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>player<span class=\"token operator\">!</span><span class=\"token punctuation\">.</span>name<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\"> 선수를 소개합니다!</span><span class=\"token template-punctuation string\">`</span></span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>as와 마찬가지로 <code class=\"language-text\">!</code> 연산자 또한 실행 에러까지 막아주지는 않는다. 타입스크립트에게 이 값이 null이 아니라고 단언해줄 뿐, 코드가 실행될 때 null 값이 들어온다면 실행 에러를 발생시킨다. 따라서 <code class=\"language-text\">!</code> 연산자는 반드시 해당 값이 null 또는 undefined가 아닌 경우에만 사용해야 한다.</p>\n<h2>3. 타입 호환(type compatibility)</h2>\n<p>타입 호환이란 서로 다른 타입이 2개 있을 때 특정 타입이 다른 타입에 포함되는지를 의미한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">\n<span class=\"token keyword\">let</span> stringVar<span class=\"token operator\">:</span><span class=\"token builtin\">string</span> <span class=\"token operator\">=</span> <span class=\"token string\">'Hello, world!'</span>\n<span class=\"token keyword\">let</span> helloVar<span class=\"token operator\">:</span><span class=\"token string\">'Hello, world!'</span> <span class=\"token operator\">=</span> <span class=\"token string\">'Hello, world!'</span>\n\n<span class=\"token comment\">// 타입이 호환되는 경우</span>\nstringVar <span class=\"token operator\">=</span> helloVar <span class=\"token comment\">// 에러 없음: string 타입이 'Hello, world!' 타입을 포함하기 때문</span>\n\n<span class=\"token comment\">// 타입이 호환되지 않는 경우</span>\nhelloVar <span class=\"token operator\">=</span> stringVar <span class=\"token comment\">// 에러 발생: 'Hello, world!'이 string 타입을 포함하지 않기 때문</span></code></pre></div>\n<h3>3.1 구조적 타이핑(structural typing)</h3>\n<p>구조적 타이핑이란 타입 유형보다는 타입 구조로 호환 여부를 판별하는 언어적 특성을 의미한다. 타입스크립트의 타입 호환은 구조적 타이핑을 따른다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">Pitcher</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    name<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n    backNumber<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">Batter</span> <span class=\"token punctuation\">{</span>\n    name<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n    backNumber<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">let</span> a<span class=\"token operator\">:</span>Pitcher <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    name<span class=\"token operator\">:</span> <span class=\"token string\">'정현수'</span><span class=\"token punctuation\">,</span>\n    backNumber<span class=\"token operator\">:</span> <span class=\"token number\">57</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">let</span> b<span class=\"token operator\">:</span>Batter <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    name<span class=\"token operator\">:</span> <span class=\"token string\">'원성준'</span><span class=\"token punctuation\">,</span>\n    backNumber<span class=\"token operator\">:</span> <span class=\"token number\">7</span>\n<span class=\"token punctuation\">}</span>\n\na <span class=\"token operator\">=</span> b <span class=\"token comment\">// 에러 없음: Pitcher와 Batter가 동일한 구조를 가지고 있기 때문</span>\nb <span class=\"token operator\">=</span> a <span class=\"token comment\">// 에러 없음</span></code></pre></div>\n<h3>3.2 객체 타입의 호환</h3>\n<p>구조적 타이핑에서 봤던 예시는 타입 별칭인 Pitcher와 인터페이스인 Batter가 완전히 동일한 구조를 가지고 있다. 하지만 완전히 동일한 구조를 가지고 있어야 호환이 되는 것은 아니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">Player</span> <span class=\"token punctuation\">{</span>\n    name<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n    backNumber<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">Pitcher</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    name<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n    backNumber<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n    arsenal<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">let</span> player<span class=\"token operator\">:</span> Player <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    name<span class=\"token operator\">:</span> <span class=\"token string\">'원성준'</span><span class=\"token punctuation\">,</span>\n    backNumber<span class=\"token operator\">:</span> <span class=\"token number\">7</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">let</span> pitcher<span class=\"token operator\">:</span> Pitcher <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    name<span class=\"token operator\">:</span> <span class=\"token string\">'정현수'</span><span class=\"token punctuation\">,</span>\n    backNumber<span class=\"token operator\">:</span> <span class=\"token number\">7</span><span class=\"token punctuation\">,</span>\n    arsenal<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'커브'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'패스트볼'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'슬라이더'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'체인지업'</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span>\n\nplayer <span class=\"token operator\">=</span> pitcher <span class=\"token comment\">// 호환 가능: pitcher 객체에 Player 인터페이스의 필수 속성인 name과 backNumber가 정의되어 있기 때문</span>\npitcher <span class=\"token operator\">=</span> player <span class=\"token comment\">// 호환 불가능: player 객체에 Pitcher 타입 별칭의 필수 속성인 arsenal이 정의되어 있지 않기 때문</span></code></pre></div>\n<p>객체 타입 호환에서 주의할 점이 하나 있는데, 타입스크립트에서 객체의 각 속성의 호환 여부를 판단할 때 해당 속성이 읽기 전용인지는 고려하지 않는다는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">{</span>\n  name<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n  age<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n \n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">ReadonlyPerson</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">readonly</span> name<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">readonly</span> age<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n \n<span class=\"token keyword\">let</span> writablePerson<span class=\"token operator\">:</span> Person <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  name<span class=\"token operator\">:</span> <span class=\"token string\">\"하일\"</span><span class=\"token punctuation\">,</span>\n  age<span class=\"token operator\">:</span> <span class=\"token number\">100</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n \n<span class=\"token comment\">// 각 객체의 속성의 읽기 전용 여부가 다르지만 호환된다.</span>\n<span class=\"token keyword\">let</span> readonlyPerson<span class=\"token operator\">:</span> ReadonlyPerson <span class=\"token operator\">=</span> writablePerson<span class=\"token punctuation\">;</span>\n \n<span class=\"token comment\">// 아래와 같이 예상치 못한 동작이 발생한다.</span>\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>readonlyPerson<span class=\"token punctuation\">.</span>age<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// prints '42'</span>\nwritablePerson<span class=\"token punctuation\">.</span>age<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n<span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>readonlyPerson<span class=\"token punctuation\">.</span>age<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// prints '43'</span></code></pre></div>\n<h3>3.3 함수 타입의 호환</h3>\n<p>함수 타입도 구조가 유사하면 호환된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">let</span> <span class=\"token function-variable function\">printMessage</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>message<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">let</span> <span class=\"token function-variable function\">printText</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>text<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>text<span class=\"token punctuation\">)</span>\n\nprintMessage <span class=\"token operator\">=</span> printText <span class=\"token comment\">// 호환 가능</span>\nprintText <span class=\"token operator\">=</span> printMessage <span class=\"token comment\">// 호환 가능</span></code></pre></div>\n<p>아래와 같이 구조가 다른 경우에는 호환이 불가능할 수도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">let</span> <span class=\"token function-variable function\">printText</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>text<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>text<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">let</span> <span class=\"token function-variable function\">printMessage</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>message<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> status<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">,</span> status<span class=\"token punctuation\">)</span>\n\nprintMessage <span class=\"token operator\">=</span> printText <span class=\"token comment\">// 호환 가능</span>\nprintText <span class=\"token operator\">=</span> printMessage <span class=\"token comment\">// 호환 불가 </span></code></pre></div>\n<p>위 예시에서 <code class=\"language-text\">printText = printMessage</code>가 호환 불가인 이유를 좀 더 자세히 설명하겠다. 변수 <code class=\"language-text\">printText</code>에는 인자를 한 개 받는 함수가 할당되어 있다. 그런 변수에 인자를 두 개 받아야 동작하는 <code class=\"language-text\">printMessage</code>라는 함수를 할당한 상황이다. 그러면 <code class=\"language-text\">printText</code>가 인자를 두 개 받을 수 있을 것 같지만 <code class=\"language-text\">printText</code>는 함수 표현식에 정의된대로 여전히 1개의 인자만 받는다. 따라서 첫 번째 인자는 전달이 가능하지만 두 번째 인자는 전달이 불가능하기 때문에 두 번째 인자는 <code class=\"language-text\">undefined</code>가 되고 예상한 것과 다른 결과 값이 나오게 된다. 이러한 이유로 <code class=\"language-text\">printText = printMessage</code>는 호환되지 않는 것이다.</p>\n<p>반면 <code class=\"language-text\">printMessage = printText</code>는 인자의 개수가 다르지만 호환이 가능하다. 변수 <code class=\"language-text\">printMessage</code>에는 인자를 두 개 받는 함수가 할당되어 있다. 그런 변수에 인자를 한 개 받아야 동작하는 <code class=\"language-text\">printText</code>라는 함수를 할당한 상황이다. 인자를 한 개만 받는 함수가 할당되어 있지만 <code class=\"language-text\">printMessage</code>는 함수 표현식에 정의된대로 여전히 인자를 두 개 받아야 한다. 따라서 첫 번째 인자만 사용되고 두 번째 인자는 버려진다. 두 번째 인자를 사용하지 않았지만 함수의 동작은 깨지지 않고 동작하기 때문에 <code class=\"language-text\">printMessage = printText</code>는 호환이 가능하다.</p>\n<p>이처럼 함수 타입의 호환은 '기존 함수 코드의 동작을 보장해 줄 수 있는가?'라는 관점에서 이해하면 된다.</p>","frontmatter":{"title":"[타입스크립트] 타입 추론, 타입 단언, 타입 호환","date":"September 21, 2023","description":"타입스크립트의 타입 추론, 타입 단언, 타입 호환을 다룹니다.","mobileImage":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB9ElEQVR42j1SS28SURQ+A4VCtXFntRJtIwIzPC3U2iowMMyAJD4WbdIubLRpNG5qq0GICzUkTTcaFy6MC+PCLtz3V9hf4L/5zHcuw+Lk3syc873OFck2MeO0MVfpIuq0IJkGYvm2fpNbdcyVAy0r10Sy5Ot9Jm/+sSeW9yBpc0+UfAgBk+VAG2aLHVyodBHJuUgUfUjWhVyuQJY2IKk1yNI6ZHlDBwketVtKThLeWUJkK+eqMiqM2K6eUaeN2pNnGBx/wfPDEfaORhiefIXT3VZyknJWgZ2WcVLpGoWJCRsVqtVsE3LzHuqb+3hz8gu7H35jb/wHR8c/cffRU1i2a2xnmwpsTWqWrqgsWQoUjOrCzOLFDhZrPVz136E0Okf1/TmutA6QWg10mCIu3u7pGS94mqXugBmQhTZMJt6U8fpaHwveAPWPfzE4/Qf74QCL1QDRydK4KColaMQ2CxWis8JgCcifrMbmPkafTzH8dobxjzMcjr+j1t9RqyrEdtWdvoyCp4olzI4nQdmg+aTryHS28HL4CbsHQ2y/eoutF6+x3HiscXAmXuiYvLnQUCGtxqYWXG20wqeUvq/PRG6sQ66tQlJ3dIgREYwgxq7JlLMyv/JgCjINNtPQ98goNKOij0vVPuZXetpHcnXBhZYDFUSlBPwPKwg5FHL3cqMAAAAASUVORK5CYII="},"backgroundColor":"transparent","images":{"fallback":{"src":"/static/205369369a5522111ce43a38f93136be/a22c4/ts-512x256x2.png","srcSet":"/static/205369369a5522111ce43a38f93136be/cadb4/ts-512x256x2.png 750w,\n/static/205369369a5522111ce43a38f93136be/a22c4/ts-512x256x2.png 856w,\n/static/205369369a5522111ce43a38f93136be/7a9e5/ts-512x256x2.png 1024w","sizes":"(min-width: 856px) 856px, 100vw"},"sources":[{"srcSet":"/static/205369369a5522111ce43a38f93136be/0b163/ts-512x256x2.avif 750w,\n/static/205369369a5522111ce43a38f93136be/1167a/ts-512x256x2.avif 856w,\n/static/205369369a5522111ce43a38f93136be/02545/ts-512x256x2.avif 1024w","type":"image/avif","sizes":"(min-width: 856px) 856px, 100vw"},{"srcSet":"/static/205369369a5522111ce43a38f93136be/11ba1/ts-512x256x2.webp 750w,\n/static/205369369a5522111ce43a38f93136be/024d1/ts-512x256x2.webp 856w,\n/static/205369369a5522111ce43a38f93136be/25be2/ts-512x256x2.webp 1024w","type":"image/webp","sizes":"(min-width: 856px) 856px, 100vw"}]},"width":856,"height":428}}}}},"previous":{"fields":{"slug":"/typescript/generics/"},"frontmatter":{"title":"[타입스크립트] 제네릭"}},"next":{"fields":{"slug":"/typescript/type-guard/"},"frontmatter":{"title":"[타입스크립트] 타입 가드"}}},"pageContext":{"id":"f2d343a0-5d77-5f5b-a96d-6377a5421862","previousPostId":"80bf46e5-c274-5ad7-8251-4db76862175b","nextPostId":"425d9e09-118c-5668-acb6-7ff861bc1929"}},"staticQueryHashes":["2841359383"],"slicesMap":{}}