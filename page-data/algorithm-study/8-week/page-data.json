{"componentChunkName":"component---src-templates-blog-post-js","path":"/algorithm-study/8-week/","result":{"data":{"site":{"siteMetadata":{"title":"하일의 작업실"}},"markdownRemark":{"id":"6fc4f7e6-30d4-50b0-9b39-57ae85429c07","excerpt":"…","html":"<h2>정렬 알고리즘</h2>\n<p>오늘은 정렬 알고리즘에 대해서 공부했습니다.</p>\n<p>먼저 정렬이란 뭘까요?</p>\n<p>정렬이란 데이터를 특정한 조건에 따라 일정한 순서가 되도록 다시 배열하는 일을 말합니다.</p>\n<p>정렬 알고리즘에는 다양한 종류가 있습니다.</p>\n<p>저마다 용도가 다르고 상황에 따른 장단점도 존재하기 때문에, 다양한 정렬 알고리즘에 대해서 공부할 필요가 있습니다.</p>\n<p>프로그래밍 언어마다 정렬을 위한 메서드가 존재하지만, 그 메서드가 어떤 정렬 알고리즘으로 구현되었는지 알고 있고, 그 알고리즘의 용도와 장단점을 알고 있다면, 그 메서드를 사용하기 적합한 상황을 이해하고 사용할 수 있을 것입니다.</p>\n<p>따라서 이번 글에서는 정렬 알고리즘 중에서도 버블 정렬, 선택 정렬, 삽입 정렬에 대해서 공부한 내용을 소개하고, 이 세 가지 정렬을 비교해보도록 하겠습니다.</p>\n<p>본격적으로 정렬에 대해서 알아보기 전에 미리 말씀을 드리자면, 예시로 사용할 대부분의 데이터는 요소로 Number 타입을 갖는 배열이고, 해당 배열을 오름차순으로 정렬한다고 가정했습니다.</p>\n<h3>버블 정렬(Bubble sort)</h3>\n<p><a href=\"https://ko.wikipedia.org/wiki/%EB%B2%84%EB%B8%94_%EC%A0%95%EB%A0%AC\">버블 정렬</a>은 배열의 두 요소를 선택하고, 두 요소가 정렬되어있다면 놔두고 아니라면 두 요소의 값을 교체하는 방식으로 진행됩니다.</p>\n<p>원소의 이동이 마치 기포가 수면 위로 올라오는 것처럼 보여서 버블 정렬이라 부른다고 합니다.</p>\n<p>배열 [ 37, 45, 29, 8 ]이 있다고 가정했을 때, 버블 정렬은 아래와 같은 방식으로 작동합니다.</p>\n<ul>\n<li>1-1회차: [ <code class=\"language-text\">37, 45</code>, 29, 8 ] => 변화 없음</li>\n<li>1-2회차: [ 37, <code class=\"language-text\">45, 29</code>, 8 ] => 45와 29의 위치를 바꿈</li>\n<li>1-3회차: [ 37, 29, <code class=\"language-text\">45, 8</code> ] => 45와 8의 위치를 바꿈</li>\n<li>2-1회차: [ <code class=\"language-text\">37, 29</code>, 8, 45 ] => 37과 29의 위치를 바꿈</li>\n<li>2-2회차: [ 29, <code class=\"language-text\">37, 8</code>, 45 ] => 37과 8의 위치를 바꿈</li>\n<li>3-1회차: [ <code class=\"language-text\">29, 8</code>, 37, 45 ] => 29와 8의 위치를 바꿈</li>\n<li>정렬 완료: [<code class=\"language-text\">8, 29, 37, 45</code>]</li>\n</ul>\n<h4>버블 정렬의 구현</h4>\n<p>버블 정렬은 아래와 같이 자바스크립트 코드로 구현할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">bubbleSort</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">arr</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 변수 i를 사용하여 배열의 끝부터 시작까지 반복합니다.</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 변수 j를 사용하여 내부 반복문을 시작하여 i-1까지 반복합니다.</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// 만약 arr[j] 가 arr[j+1]보다 크다면 두 값을 바꿉니다.</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> arr<span class=\"token punctuation\">[</span>j <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// 만약 arr[j] 가 arr[j+1]보다 크다면 두 값을 바꿉니다.</span>\n        <span class=\"token punctuation\">;</span><span class=\"token punctuation\">[</span>arr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">[</span>j <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>arr<span class=\"token punctuation\">[</span>j <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// 정렬된 배열을 반환합니다.</span>\n  <span class=\"token keyword\">return</span> arr\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">bubbleSort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token number\">37</span><span class=\"token punctuation\">,</span> <span class=\"token number\">45</span><span class=\"token punctuation\">,</span> <span class=\"token number\">29</span><span class=\"token punctuation\">,</span> <span class=\"token number\">8</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// [ 8, 29, 37, 45 ]</span></code></pre></div>\n<p>위와 같은 형태는 [37, 45, 29, 8]과 같이 처음부터 끝까지 정렬이 필요한 경우에는 효율적일지 몰라도,</p>\n<p>[1, 2, 4, 3, 5]와 같이 이미 어느정도 정렬이 이루어진 배열에 대해서는 비효율적입니다.</p>\n<p>위와 같은 형태로 [1, 2, 4, 3, 5]라는 배열을 버블 정렬할 경우,</p>\n<p>4와 3의 위치를 바꾸고 나서 배열의 정렬이 완료되었음에도, 반복문이 끝날 때까지 계속 정렬합니다.</p>\n<ul>\n<li>1-1회차: [ <code class=\"language-text\">1, 2</code>, 4, 3, 5 ]</li>\n<li>1-2회차: [ 1, <code class=\"language-text\">2, 4</code>, 3, 5 ]</li>\n<li>1-3회차: [ 1, 2, <code class=\"language-text\">4, 3</code>, 5 ]</li>\n<li>1-4회차: [ 1, 2, 3, <code class=\"language-text\">4, 5</code> ] (정렬은 이미 완료 되었으나...)</li>\n<li>2-1회차: [ <code class=\"language-text\">1, 2</code>, 3, 4, 5 ]</li>\n<li>2-2회차: [ 1, <code class=\"language-text\">2, 3</code>, 4, 5 ]</li>\n<li>2-3회차: [ 1, 2, <code class=\"language-text\">3, 4</code>, 5 ]</li>\n<li>...</li>\n<li>4-1회차: [ 1, 2, 3, 4, 5 ] (반복문 종료... 너무 비효율적이다.)</li>\n</ul>\n<p>코드의 개선이 필요합니다.</p>\n<h3>버블 정렬의 개선</h3>\n<p>반복문은 끝나지 않았지만, 이미 정렬이 완료되었음을 어떻게 알 수 있을까요?</p>\n<p>버블 정렬은 배열의 두 요소 중 첫 번째 요소가 두 번째 요소보다 값이 크면 두 요소의 값을 교체합니다.</p>\n<p>그렇다면, 반복문을 시행했을 때 이러한 <code class=\"language-text\">교체 과정이 일어나지 않으면</code>, 해당 배열은 이미 정렬이 완료된 상태라는 것을 알 수 있습니다.</p>\n<p>그렇다면 교체 과정의 유무를 체크하는 변수 noSwaps를 이용해서 코드를 개선해보겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">bubbleSort</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">arr</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// arr[j]과 arr[j + 1]의 값의 교체를 체크하는 변수 noSwaps을 선언합니다.</span>\n  <span class=\"token keyword\">let</span> noSwaps\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 반복 시작시 noSwaps에 true를 할당합니다.</span>\n    noSwaps <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> arr<span class=\"token punctuation\">[</span>j <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token punctuation\">;</span><span class=\"token punctuation\">[</span>arr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">[</span>j <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>arr<span class=\"token punctuation\">[</span>j <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span>\n        <span class=\"token comment\">// 값의 교체가 일어났을 경우 noSwaps에 false를 할당합니다.</span>\n        noSwaps <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\">// 내부 반복문을 실행했음에도 여전히 noSwaps에 true가 할당되어있다면 반복문을 멈춥니다.</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>noSwaps<span class=\"token punctuation\">)</span> <span class=\"token keyword\">break</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">return</span> arr\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">bubbleSort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// [ 1, 2, 3, 4, 5 ]</span></code></pre></div>\n<p>개선된 코드로 [1, 2, 4, 3, 5]를 버블 정렬한다면 어떤 과정을 거칠까요?</p>\n<ul>\n<li>1-1회차: [ <code class=\"language-text\">1, 2</code>, 4, 3, 5 ]</li>\n<li>1-2회차: [ 1, <code class=\"language-text\">2, 4</code>, 3, 5 ]</li>\n<li>1-3회차: [ 1, 2, <code class=\"language-text\">4, 3</code>, 5 ]</li>\n<li>1-4회차: [ 1, 2, 3, <code class=\"language-text\">4, 5</code> ] (정렬 완료!)</li>\n<li>2-1회차: [ <code class=\"language-text\">1, 2</code>, 3, 4, 5 ]</li>\n<li>2-2회차: [ 1, <code class=\"language-text\">2, 3</code>, 4, 5 ]</li>\n<li>2-3회차: [ 1, 2, <code class=\"language-text\">3, 4</code>, 5 ] (교환이 일어나지 않았네? 여기서 반복문 종료!)</li>\n</ul>\n<h3>선택 정렬(Selection sort)</h3>\n<p><a href=\"https://ko.wikipedia.org/wiki/%EC%84%A0%ED%83%9D_%EC%A0%95%EB%A0%AC\">선택 정렬</a>은 주어진 배열에서 최솟값을 찾고, 그 값을 맨 앞에 위치한 값과 교체한 다음, 이 작업을 맨 앞 위치한 값을 뺀 나머지 배열에 대해서 반복하는 정렬 알고리즘입니다.</p>\n<p>배열 [ 34, 22, 10, 19 ]이 있다고 가정했을 때, 선택 정렬은 아래와 같은 방식으로 작동합니다.</p>\n<ul>\n<li>\n<p>1-1회차: [ <code class=\"language-text\">34, 22</code>, 10, 19 ] => 최솟값: 22</p>\n</li>\n<li>\n<p>1-2회차: [ 34, <code class=\"language-text\">22, 10</code>, 19 ] => 최솟값: 10</p>\n</li>\n<li>\n<p>1-3회차: [ 34, 22, <code class=\"language-text\">10, 19</code> ] => 최솟값: 10</p>\n<ul>\n<li>1회차 종료: [ <code class=\"language-text\">10</code>, 22, 34, 19 ]</li>\n</ul>\n</li>\n<li>\n<p>2-1회차: [ 10, <code class=\"language-text\">22, 34</code>, 19 ] => 최솟값: 22</p>\n</li>\n<li>\n<p>2-2회차: [ 10, <code class=\"language-text\">22</code>, 34, <code class=\"language-text\">19</code> ] => 최솟값: 19</p>\n<ul>\n<li>2회차 종료: [ 10, <code class=\"language-text\">19</code>, 34, 22 ]</li>\n</ul>\n</li>\n<li>\n<p>3-1회차: [ 10, 19, <code class=\"language-text\">34, 22</code> ] => 최솟값: 22</p>\n<ul>\n<li>3회차 종료: [ 10, 19, <code class=\"language-text\">22</code>, 34 ]</li>\n</ul>\n</li>\n<li>\n<p>4회차: [ 10, 19, 22, <code class=\"language-text\">34</code> ] => 정렬 완료</p>\n</li>\n</ul>\n<h4>선택 정렬의 구현</h4>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">selectionSort</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">arr</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 배열이 정렬될 때까지 다음 요소에 대해 이 작업을 반복합니다.</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> arr<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 최솟값을 할당할 변수를 선언하고 첫 번째 요소의 인덱스를 할당합니다.</span>\n    <span class=\"token keyword\">let</span> min <span class=\"token operator\">=</span> i\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> j <span class=\"token operator\">=</span> i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> arr<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// 더 작은 숫자를 찾을 때까지 이 요소를 배열의 다음 요소와 비교합니다.</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> arr<span class=\"token punctuation\">[</span>min<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// 더 작은 숫자가 발견되면 그 작은 숫자의 인덱스를 새로운 '최소값'으로 할당하고 배열의 끝까지 반복합니다.</span>\n        min <span class=\"token operator\">=</span> j\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\">// \"최소값\"이 처음에 시작한 값(인덱스)이 아닌 경우 두 값을 바꿉니다.</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">!==</span> min<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token punctuation\">;</span><span class=\"token punctuation\">[</span>arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">[</span>min<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>arr<span class=\"token punctuation\">[</span>min<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> arr\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">selectionSort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token number\">34</span><span class=\"token punctuation\">,</span> <span class=\"token number\">22</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token number\">19</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// [ 10, 19, 22, 34 ]</span></code></pre></div>\n<h3>삽입 정렬(Insertion sort)</h3>\n<p><a href=\"https://ko.wikipedia.org/wiki/%EC%82%BD%EC%9E%85_%EC%A0%95%EB%A0%AC\">삽입 정렬</a>은 자료 배열의 모든 요소를 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교하여, 자신의 위치를 찾아 삽입함으로써 정렬을 완성하는 알고리즘입니다.</p>\n<p>배열 [5, 3, 4, 1, 2]가 있다고 가정했을 때, 삽입 정렬은 아래와 같은 방식으로 이뤄집니다.</p>\n<ul>\n<li>0회차: [<U>5</U>, <code class=\"language-text\">3</code>, 4, 1, 2] = 현재값 3, 정렬완료: [ 5 ]</li>\n<li>1회차: [ <U>3, 5</U>, <code class=\"language-text\">4</code>, 1, 2 ] = 현재값 4, 정렬완료: [ 3, 5 ]</li>\n<li>2회차: [ <U>3, 4, 5</U>, <code class=\"language-text\">1</code>, 2 ] = 현재값 1, 정렬완료: [ 3, 4, 5 ]</li>\n<li>3회차: [ <U>1, 3, 4, 5</U>, <code class=\"language-text\">2</code> ] = 현재값 2, 정렬완료: [ 1, 3, 4, 5 ]</li>\n<li>4회차: [ <U>1, 2, 3, 4, 5</U> ] => 정렬완료</li>\n</ul>\n<h4>삽입 정렬의 구현</h4>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">insertionSort</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">arr</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> copiedArr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">...</span>arr<span class=\"token punctuation\">]</span>\n  <span class=\"token comment\">//배열에서 두 번째 요소를 선택하는 것으로 시작합니다.</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> copiedArr<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">//이제 두 번째 요소를 그 앞의 요소와 비교합니다.</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>copiedArr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> copiedArr<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// 두 번째 요소가 앞의 요소보다 작다면 두 번째 요소를 이미 정렬된 부분에 삽입합니다.</span>\n      <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> i<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// 두 번째 요소가 삽입 될 위치를 찾고 삽입합니다.</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>copiedArr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> copiedArr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">const</span> cuttedVal <span class=\"token operator\">=</span> copiedArr<span class=\"token punctuation\">.</span><span class=\"token function\">splice</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n          copiedArr<span class=\"token punctuation\">.</span><span class=\"token function\">splice</span><span class=\"token punctuation\">(</span>j<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span>cuttedVal<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\">//배열이 정렬될 때까지 이 과정을 반복합니다.</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> copiedArr\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">insertionSort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token number\">9</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">7</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">8</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">6</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]</span></code></pre></div>\n<h3>버블, 선택, 삽입 정렬 비교</h3>\n<p>버블, 선택, 삽입 정렬을 시간 복잡도를 기준으로 비교하면 아래와 같습니다.</p>\n<ul>\n<li>\n<p>버블 정렬 - 최상: O(n), 평균: O(n²), 최악: O(n²)</p>\n</li>\n<li>\n<p>선택 정렬 - 최상: O(n²), 평균: O(n²), 최악: O(n²)</p>\n</li>\n<li>\n<p>삽입 정렬 - 최상: O(n), 평균: O(n²), 최악: O(n²)</p>\n</li>\n</ul>\n<p>(공간 복잡도는 O(1)으로 모두 동일합니다.)</p>\n<h4>최상의 경우에서 왜 차이가 날까?</h4>\n<p>세 정렬의 차이는 최상의 경우에서 발생합니다.</p>\n<p>배열이 이미 어느정도 정렬이 완료된 상태라고 가정했을 때,</p>\n<p>버블 정렬과 삽입 정렬은, 정렬이 이루어지지 않은 요소들에 대해서만 값을 비교하고 교체합니다.</p>\n<p>즉, 정렬이 많이 이루어져 있을수록 연산의 갯수가 줄어듭니다.</p>\n<p>하지만 선택 정렬의 경우, 배열의 정렬 정도와 상관없이 매 회차 최소값을 찾아내야 하기 때문에,</p>\n<p>배열의 정렬 정도에 따라 연산 갯수가 줄어들지 않습니다.</p>\n<h4>평균적으로 O(n²) 시간복잡도를 갖는 이 정렬들은 쓸모가 없을까?</h4>\n<p>버블 정렬, 선택 정렬, 삽입 정렬과 같이 O(n²) 시간복잡도를 갖는 정렬들은 추후에 다룰 알고리즘들에 비해서 시간복잡도는 떨어질지 모르겠으나, 정렬해야 하는 데이터 집합의 크기가 작을 경우에는 효과적으로 사용됩니다.</p>\n<p>그리고, 삽입 정렬의 경우 이미 정렬된 데이터에 새로운 데이터를 삽입하고 다시 정렬해야 하는 경우 사용하기 좋습니다.</p>\n<p>생각해보면 당연합니다.</p>\n<p>새로운 요소를 이미 정렬된 배열 부분과 비교하여 해당 요소의 위치를 찾아 삽입하는 연산이, 이미 삽입 정렬 알고리즘 자체에 구현되어있기 때문입니다.</p>\n<h3>프로그래머스 문제 적용</h3>\n<p>정렬 알고리즘을 배웠으니 프로그래머스에서 문제를 하나 가져와서 풀어보려고 합니다.</p>\n<p>이번에 가져온 문제는 프로그래머스 코딩테스트 연습 Lv.1 문제 <a href=\"https://school.programmers.co.kr/learn/courses/30/lessons/42748\">K번째수</a>입니다.</p>\n<p>해당 문제는 프로그래머스 사이트의 코딩테스트 고득점 Kit의 <a href=\"https://school.programmers.co.kr/learn/courses/30/parts/12198\">정렬</a> 항목에 있는 문제입니다.</p>\n<p>처음에는 한 문제를 버블 정렬, 삽입 정렬, 선택 정렬 세 가지 방식으로 풀어보려고 했으나,</p>\n<p>그것보다는 문제를 읽고 어떤 정렬 방식을 선택할 것인지 고민해보는 것이 더 중요하다고 판단했기 때문에,</p>\n<p>문제를 읽고 적합한 정렬 알고리즘을 선택하여 풀어봤습니다.</p>\n<p>먼저 문제를 잠깐 보겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">배열 array의 i번째 숫자부터 j번째 숫자까지 자르고 정렬했을 때<span class=\"token punctuation\">,</span> k번째에 있는 수를 구하려 합니다<span class=\"token punctuation\">.</span>\n\n예를 들어 array가 <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">6</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">7</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> i <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> j <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> k <span class=\"token operator\">=</span> <span class=\"token number\">3</span>이라면\n\n<span class=\"token operator\">-</span> array의 <span class=\"token number\">2</span>번째부터 <span class=\"token number\">5</span>번째까지 자르면 <span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">6</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span>입니다<span class=\"token punctuation\">.</span>\n<span class=\"token operator\">-</span> <span class=\"token number\">1</span>에서 나온 배열을 정렬하면 <span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">6</span><span class=\"token punctuation\">]</span>입니다<span class=\"token punctuation\">.</span>\n<span class=\"token operator\">-</span> <span class=\"token number\">2</span>에서 나온 배열의 <span class=\"token number\">3</span>번째 숫자는 <span class=\"token number\">5</span>입니다<span class=\"token punctuation\">.</span>\n\n배열 array<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">,</span> j<span class=\"token punctuation\">,</span> k<span class=\"token punctuation\">]</span>를 원소로 가진 <span class=\"token number\">2</span>차원 배열 commands가 매개변수로 주어질 때<span class=\"token punctuation\">,</span> \ncommands의 모든 원소에 대해 앞서 설명한 연산을 적용했을 때 나온 결과를 \n배열에 담아 <span class=\"token keyword\">return</span> 하도록 solution 함수를 작성해주세요<span class=\"token punctuation\">.</span></code></pre></div>\n<p>문제 해결 접근법과 상세한 풀이는 아래에서 소개하겠습니다.</p>\n<h4>문제 해결 접근법과 상세 풀이</h4>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">/* 문제 해결 접근법\n- 이해\n  - 배열 commands의 각 원소에 대해서 const slicedArr = arr.slice(i-1, j)을 진행하고\n  - 잘라낸 배열을 오름차순 정렬하여 slicedArr[k-1]를 반환하고, 그 값들을 모아서 최종 반환하면 되겠다.\n  - 잘라낸 배열은 데이터 셋이 작으니까 버블, 선택, 삽입 정렬 중에 고르면 될 것 같다.\n  - 새로운 값을 받아 정렬하는 것은 아니니까 삽입 정렬은 제외하고, \n  - 어느정도 정렬이 되어있으면 성능이 더 잘 나오는 버블정렬로 풀어야겠다.\n- 인풋\n  - array: 1~100 사이의 값의 원소를 갖는 길이 1~100 사이의 배열\n  - commands: 길이 3을 갖는 배열을 원소로 갖는 길이 1~50 사이의 배열\n- 아웃풋\n  - return: 각 커맨드에 대한 반환값을 담은 배열로, commands와 길이가 같아야 한다.\n- 예시\n  - array: [1, 5, 2, 6, 3, 7, 4]\n  - commands: [[2, 5, 3], [4, 4, 1], [1, 7, 3]]\n  - return: [5, 6, 3]\n*/</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">bubbleSort</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">arr</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> noSwaps\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    noSwaps <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> arr<span class=\"token punctuation\">[</span>j <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token punctuation\">;</span><span class=\"token punctuation\">[</span>arr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">[</span>j <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>arr<span class=\"token punctuation\">[</span>j <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span>\n        noSwaps <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>noSwaps<span class=\"token punctuation\">)</span> <span class=\"token keyword\">break</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> arr\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">solution</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">array<span class=\"token punctuation\">,</span> commands</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 최종 반환 값을 할당할 변수 answer를 선언하고 빈 배열을 할당한다.</span>\n    <span class=\"token keyword\">var</span> answer <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token comment\">// commands에 각 원소에 대해서 반복문을 실행한다.</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> command <span class=\"token keyword\">of</span> commands<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// 변수 i, j, k을 선언하고 각각 값을 할당한다.</span>\n        <span class=\"token keyword\">const</span> i <span class=\"token operator\">=</span> command<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span>\n        <span class=\"token keyword\">const</span> j <span class=\"token operator\">=</span> command<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n        <span class=\"token keyword\">const</span> k <span class=\"token operator\">=</span> command<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span>\n        <span class=\"token comment\">// 변수 slicedArr를 선언하고 array.slice(i-1, j)를 할당한다.</span>\n        <span class=\"token keyword\">const</span> slicedArr <span class=\"token operator\">=</span> array<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span>i<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> j<span class=\"token punctuation\">)</span>\n        <span class=\"token comment\">// slicedArr를 오름차순으로 버블정렬한다.</span>\n        <span class=\"token function\">bubbleSort</span><span class=\"token punctuation\">(</span>slicedArr<span class=\"token punctuation\">)</span>\n        <span class=\"token comment\">// answer에 slicedArr[k-1]을 push한다.</span>\n        answer<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>slicedArr<span class=\"token punctuation\">[</span>k<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    \n    <span class=\"token comment\">// answer를 반환한다.</span>\n    <span class=\"token keyword\">return</span> answer<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3>회고</h3>\n<p>이제 겨우 세 가지 정렬 알고리즘을 배웠고, 이 알고리즘들이 실제로 많이 쓰이는지 아닌지는 저로서는 알 수가 없습니다.</p>\n<p>(시간복잡도가 높은 알고리즘인 만큼 자주 사용하지는 않을 것 같지만...)</p>\n<p>하지만 그럼에도 정렬 알고리즘을 배우는 것이 재미있었던 이유는, 하나의 목표를 달성하기 위한 다양한 방법을 생각해볼 수 있었기 때문입니다.</p>\n<p>이번 프로그래머스 문제도 쉽고 간단한 문제였지만, 그 안에서도 더 효율적인 정렬 알고리즘이 무엇일지 생각해보는게 즐거웠습니다.</p>\n<p>요즘 코딩테스트 문제를 푸는 것이 즐거워졌습니다.</p>\n<p>아직 부족하지만 이 스터디를 통해서 다양한 알고리즘을 배우고 있고, 어떤 문제를 만났을 때 '내가 배웠던 알고리즘으로 풀 수 있을까?' 고민해보는 과정이 즐겁습니다.</p>\n<p>한 문제에 다양한 솔루션이 떠오를 때는 더 즐겁습니다.</p>\n<p>이렇게 즐거운 마음으로 오늘은 여기서 글을 마치겠습니다.</p>\n<p>읽어주셔서 감사합니다.</p>\n<h3>참고자료</h3>\n<ul>\n<li>프로그래머스 코딩 테스트 연습 - K번째수</li>\n</ul>\n<p>문제 링크: <a href=\"https://school.programmers.co.kr/learn/courses/30/lessons/42748\">https://school.programmers.co.kr/learn/courses/30/lessons/42748</a></p>\n<ul>\n<li>Best JavaScript Data Structures &#x26; Algorithms Course by Udemy, last updated January 2022, accessed April 5, 2023</li>\n</ul>\n<p>강의 링크: <a href=\"https://www.udemy.com/course/best-javascript-data-structures/\">https://www.udemy.com/course/best-javascript-data-structures/</a></p>","frontmatter":{"title":"정렬 알고리즘 - 버블, 선택, 삽입 정렬","date":"May 24, 2023","description":"버블, 선택, 삽입 정렬을 공부하고 문제를 풀어봤습니다.","mobileImage":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABo0lEQVR42l2SW0vDQBCF82/rg0KxSJW+iaXqa7Xa5rK9KGovSWNMN0mb1kv9Cz4KgvgiqCCCinJk9lKChaFDZvabc3bWMAcclhuBDRPx3+iPYLuRyOu9ENaAw3a5ykdwvEjUqY96KK+r3PFiGAR0hrEEebEEC0iEVpCiHV6idTFDM5jiJJ7DGY5Fjc5YruxjKqcwiExQPZFgZn+E9kWKyp6JXH4Npa0KNjbLyOULKFcbYP5k0U+qLDWAxEiFnpygi9RsujGqVgvThGN2NUeU3iBNYlRNBltcDxdCsiEs02Gik11SR/KZn+CwF8KPUtDv7hV4eXsC8IsBn6F2Fgg1FASx1b2SmH+WuSpwHHRDDEYJHj7f8f31DOADP4/36J5HomarcwvbimFoOstcslxUgn3WwWnQRxq0MU0T3Ho+6qwDU6nRNvXLaPoJKeTSriu3TSGBY+zUHCyvFrFUKGGlWMJ6eRu7hwytYCIAJCbrTijMvjsqElxPJuhxdI0jLp8ObZeU6z69SN1P3wySqSEaTEOY2mSjH8IUDzpe2LMyfWKhGTF/ZXxbdhmpbtsAAAAASUVORK5CYII="},"backgroundColor":"transparent","images":{"fallback":{"src":"/static/6d2bce79832bb7a2be88fc055572e63e/a22c4/algorithm-512x256x2.png","srcSet":"/static/6d2bce79832bb7a2be88fc055572e63e/cadb4/algorithm-512x256x2.png 750w,\n/static/6d2bce79832bb7a2be88fc055572e63e/a22c4/algorithm-512x256x2.png 856w,\n/static/6d2bce79832bb7a2be88fc055572e63e/7a9e5/algorithm-512x256x2.png 1024w","sizes":"(min-width: 856px) 856px, 100vw"},"sources":[{"srcSet":"/static/6d2bce79832bb7a2be88fc055572e63e/0b163/algorithm-512x256x2.avif 750w,\n/static/6d2bce79832bb7a2be88fc055572e63e/1167a/algorithm-512x256x2.avif 856w,\n/static/6d2bce79832bb7a2be88fc055572e63e/02545/algorithm-512x256x2.avif 1024w","type":"image/avif","sizes":"(min-width: 856px) 856px, 100vw"},{"srcSet":"/static/6d2bce79832bb7a2be88fc055572e63e/11ba1/algorithm-512x256x2.webp 750w,\n/static/6d2bce79832bb7a2be88fc055572e63e/024d1/algorithm-512x256x2.webp 856w,\n/static/6d2bce79832bb7a2be88fc055572e63e/25be2/algorithm-512x256x2.webp 1024w","type":"image/webp","sizes":"(min-width: 856px) 856px, 100vw"}]},"width":856,"height":428}}}}},"previous":{"fields":{"slug":"/algorithm-study/7-week/"},"frontmatter":{"title":"탐색 알고리즘"}},"next":{"fields":{"slug":"/algorithm-study/9-week/"},"frontmatter":{"title":"정렬 알고리즘 - 합병, 퀵, 기수 정렬"}}},"pageContext":{"id":"6fc4f7e6-30d4-50b0-9b39-57ae85429c07","previousPostId":"ff6230d7-73c6-586f-ac11-ac8c042c3d66","nextPostId":"894d0b24-d127-5681-8f48-d924a94bcefe"}},"staticQueryHashes":["2841359383"],"slicesMap":{}}