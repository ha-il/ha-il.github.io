{"componentChunkName":"component---src-templates-blog-post-js","path":"/algorithm-study/9-week/","result":{"data":{"site":{"siteMetadata":{"title":"하일의 작업실"}},"markdownRemark":{"id":"894d0b24-d127-5681-8f48-d924a94bcefe","excerpt":"작업 시간 새로운 정렬…","html":"<ul>\n<li>작업 시간</li>\n</ul>\n<h2>새로운 정렬 3 가지</h2>\n<p><a href=\"https://ha-il.github.io/algorithm-study/8-week/\">지난 포스트</a>에서는 정렬 알고리즘 중에서도 버블 정렬, 선택 정렬, 삽입 정렬에 대해서 공부했습니다.</p>\n<p>이번에는 방금 언급한 세 가지 정렬보다 시간 복잡도 측면에서 성능이 좋은 정렬 알고리즘을 공부했습니다.</p>\n<p>이번에 공부한 정렬 알고리즘은, <code class=\"language-text\">합병 정렬</code>, <code class=\"language-text\">퀵 정렬</code>, <code class=\"language-text\">기수 정렬</code>입니다.</p>\n<h3>합병 정렬(Merge sort)</h3>\n<p><a href=\"https://ko.wikipedia.org/wiki/%ED%95%A9%EB%B3%91_%EC%A0%95%EB%A0%AC\">합병 정렬</a>은 비교 기반의 정렬 알고리즘으로, <a href=\"https://ha-il.github.io/algorithm-study/5-week/\">분할과 정복 알고리즘</a>의 일종입니다.</p>\n<p>데이터가 배열이라고 가정했을 때, 배열을 n개로 분할하는데, 분할된 배열의 길이가 1 또는 0이 될 때까지 분할을 반복합니다.</p>\n<p>최대로 분할된 배열들을 정렬 기준에 맞춰서 다시 병합하여 최종적으로 정렬된 배열을 반환하는 것이 합병 정렬입니다.</p>\n<p>분할하는 개수에 따라서 n-way 합병 정렬이라고도 불리는데, 가장 흔하게 사용되는 것은 배열을 절반으로 분할하는 <code class=\"language-text\">2-way 합병 정렬</code>입니다.</p>\n<p>이번 글에서는 2-way 합병 정렬을 기준으로 합병 정렬을 설명하겠습니다.</p>\n<p>우선 정의로만 봤을 때는 이해가 쉽지 않기 때문에 예시를 작성해보겠습니다.</p>\n<ul>\n<li>예시: [4, 2, 7, 1, 5, 8, 6, 3] 를 오름차순으로 합병 정렬하는 경우\n<ul>\n<li>분할 1회차: [4, 2, 7, 1], [5, 8, 6, 3]</li>\n<li>분할 2회차: [4, 2], [7, 1], [5, 8], [6, 3]</li>\n<li>분할 3회차: [4], [2], [7], [1], [5], [8], [6], [3]</li>\n<li>합병 1회차: [2, 4], [1, 7], [5, 8], [3, 6]</li>\n<li>합병 2회차: [1, 2, 4, 7], [3, 5, 6, 8]</li>\n<li>합병 3회차: [1, 2, 3, 4, 5, 6, 7, 8]</li>\n</ul>\n</li>\n</ul>\n<p>아직 코드를 통해 구현해보지 않았지만, 이미 이 과정만 봐도 시간복잡도가 log n과 관련이 있을 것임을 충분히 유추할 수 있습니다.</p>\n<p>이 과정을 이해한 상태로 합병 정렬을 자바스크립트로 구현해보겠습니다.</p>\n<h4>합병 정렬의 구현</h4>\n<p>합병 정렬은 크게 보면 분할과 합병이라는 두 가지 연산이 필요합니다.</p>\n<p>하나의 함수에 다 작성할 수도 있겠지만, 헬퍼 함수를 따로 정의해서 역할을 분담하면 코드가 더 깔끔해질 것 같습니다.</p>\n<p>합병에 대한 연산을 <code class=\"language-text\">merge</code>라는 헬퍼 함수를 정의하여 구현하고, 헬퍼 함수를 사용해서 합병 정렬을 구현할 <code class=\"language-text\">mergeSort</code>라는 함수를 정의해보겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">merge</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">arr1<span class=\"token punctuation\">,</span> arr2</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 변수 results를 선언하고 빈 배열을 할당합니다.</span>\n  <span class=\"token keyword\">let</span> results <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n  <span class=\"token comment\">// 두 배열을 각각 순회할 변수 i와 j를 선언하고 0을 할당합니다.</span>\n  <span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n  <span class=\"token keyword\">let</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> \n  <span class=\"token comment\">// i 또는 j가 배열 끝에 도달할 때까지 실행할 반복문을 작성합니다.</span>\n  <span class=\"token comment\">// 이유: 두 배열 사이의 요소 값을 비교하는 것이기 때문에, </span>\n  <span class=\"token comment\">//      한 쪽 배열이 끝에 도달했다면 반복문을 시행할 이유가 없기 때문입니다.</span>\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">&lt;</span> arr1<span class=\"token punctuation\">.</span>length <span class=\"token operator\">&amp;&amp;</span> j <span class=\"token operator\">&lt;</span> arr2<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 첫 번째 배열의 값이 두 번째 배열의 값보다 작으면 첫 번째 배열의 값을 results에 push하고 i를 1 증가시킵니다.</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>arr2<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> arr1<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      results<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>arr1<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n      i<span class=\"token operator\">++</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// 첫 번째 배열의 값이 두 번째 배열의 값보다 크면 두 번째 배열의 값을 results에 push하고 j를 1 증가시킵니다.</span>\n      results<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>arr2<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n      j<span class=\"token operator\">++</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// 한 배열을 모두 순회했다면 다른 배열의 나머지 값을 모두 results에 push합니다.</span>\n  <span class=\"token comment\">// 이유: merge 함수는 이미 정렬이 된 두 배열을 인수로 받기 때문에</span>\n  <span class=\"token comment\">//      순회를 마치고 남은 배열의 요소를 push해도 정렬이 깨지지 않습니다.</span>\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">&lt;</span> arr1<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    results<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>arr1<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    i<span class=\"token operator\">++</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>j <span class=\"token operator\">&lt;</span> arr2<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    results<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>arr2<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    j<span class=\"token operator\">++</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> results\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">mergeSort</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">arr</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 비어 있거나 요소가 하나만 있는 배열이 나올 때까지 배열을 반으로 나눕니다.(재귀의 종료조건 입니다.)</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">.</span>length <span class=\"token operator\">&lt;=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> arr\n  <span class=\"token comment\">// 배열의 중간값을 구합니다.</span>\n  <span class=\"token keyword\">let</span> mid <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">floor</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">.</span>length <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n  <span class=\"token comment\">// 중간 값을 기준으로 배열을 왼쪽과 오른쪽으로 나눕니다.</span>\n  <span class=\"token comment\">// 나눈 배열에 대해서 mergeSort를 재귀 호출합니다.</span>\n  <span class=\"token keyword\">let</span> left <span class=\"token operator\">=</span> <span class=\"token function\">mergeSort</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> mid<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">let</span> right <span class=\"token operator\">=</span> <span class=\"token function\">mergeSort</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span>mid<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token comment\">// 배열의 왼쪽과 오른쪽 부분을 병합하여 반환합니다.</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">merge</span><span class=\"token punctuation\">(</span>left<span class=\"token punctuation\">,</span> right<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h4>합병 정렬의 시간 복잡도</h4>\n<p>합병 정렬의 시간 복잡도를 알아보기 위해, 합병 정렬이 어떻게 이뤄지는지 예시를 다시 한 번 보겠습니다.</p>\n<ul>\n<li>예시: [4, 2, 7, 1, 5, 8, 6, 3] 를 오름차순으로 합병 정렬하는 경우\n<ul>\n<li>분할 1회차: [4, 2, 7, 1], [5, 8, 6, 3]</li>\n<li>분할 2회차: [4, 2], [7, 1], [5, 8], [6, 3]</li>\n<li>분할 3회차: [4], [2], [7], [1], [5], [8], [6], [3]</li>\n<li>합병 1회차: [2, 4], [1, 7], [5, 8], [3, 6]</li>\n<li>합병 2회차: [1, 2, 4, 7], [3, 5, 6, 8]</li>\n<li>합병 3회차: [1, 2, 3, 4, 5, 6, 7, 8]</li>\n</ul>\n</li>\n</ul>\n<p>위 예시를 보면 알 수 있듯이 길이가 8인 배열에 대해서 3번의 분할이 이뤄지고 있으므로, 원소의 갯수 n에 대해서 log n의 비율로 연산이 이뤄지고 있습니다.</p>\n<p>하지만 여기서 끝이 아니라, 분할한 배열들을 합병하는 과정에서 각 배열의 요소를 비교하기 위해 각 배열을 순회하는데, 이 때 배열에 길이 n에 따라서 연산은 n배 증가합니다.</p>\n<p>따라서 합병 정렬은 O(n log n)의 시간 복잡도를 가집니다.</p>\n<p>이미 정렬된 배열이라고 해도, 분할하고 합병하는 과정은 변함이 없기 때문에</p>\n<p>합병 정렬은 최상, 최악, 평균 모든 경우에서 O(n log n)의 시간 복잡도를 가집니다.</p>\n<p>합병 정렬은 배열의 길이가 0 또는 1이 될 때까지 분할하기 때문에, 배열의 길이에 따라서 분할된 후의 배열의 갯수도 많아질 것입니다.</p>\n<p>따라서 공간 복잡도는 O(n)으로 볼 수 있습니다.</p>\n<h3>퀵 정렬(Quick sort)</h3>\n<p>합병 정렬과 마찬가지로 <a href=\"https://ko.wikipedia.org/wiki/%ED%80%B5_%EC%A0%95%EB%A0%AC\">퀵 정렬</a>또한 비교 기반의 정렬 알고리즘으로, <a href=\"https://ha-il.github.io/algorithm-study/5-week/\">분할과 정복 알고리즘</a>의 일종입니다.</p>\n<p>정렬하고자하는 데이터가 배열이라고 할 때, 퀵 정렬은 배열의 원소 하나를 고르는데, 이때 고른 원소를 흔히 <code class=\"language-text\">피벗(pivot: 중심점)</code>이라고 부릅니다.</p>\n<p>배열의 모든 원소는 피벗이 될 수 있습니다.</p>\n<p>퀵 정렬은 피벗을 기준으로 피벗 앞에는 피벗보다 값이 작은 모든 원소들을 배치하고, 피벗 뒤에는 피벗보다 값이 큰 모든 원소들을 배치하여, 피벗을 기준으로 배열을 둘로 나눕니다.</p>\n<p>퀵 정렬 또한 정의만으로 이해하기는 어렵기 때문에 예시를 통해 이해해보겠습니다.</p>\n<p>참고로 아래 예시에서는 배열의 첫번째 원소를 피벗으로 설정했습니다.</p>\n<ul>\n<li>예시: [4, 2, 7, 1, 5, 8, 6, 3] 를 오름차순으로 퀵 정렬하는 경우</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">- 0회차: [4(피벗), 2, 7, 1, 5, 8, 6, 3] \n\n- 1회차:              4\n        2(피벗), 1, 3   5(피벗), 8, 6, 7\n\n- 2회차:              4\n            2             5\n          1   3             8(피벗), 6, 7\n\n- 3회차:              4\n            2             5\n          1   3                        8             \n                            6(피벗), 7\n\n- 4회차:              4\n              2             5\n            1   3                      8             \n                                6\n                                    7\n\n- 최종: [1, 2, 3, 4, 5, 6, 7, 8]</code></pre></div>\n<h4>퀵 정렬의 구현</h4>\n<p>퀵 정렬에도 여러가지 연산이 들어가기 때문에, 이번에도 헬퍼 함수를 작성해서 역할을 분담해보겠습니다.</p>\n<p>값의 교체가 일어나야하기 때문에 <code class=\"language-text\">swap</code>이라는 함수를 따로 정의했고,</p>\n<p>매 연산마다 피벗이 바뀌기 때문에 <code class=\"language-text\">pivot</code>이라는 함수를 정의하여 피벗 값을 구합니다.</p>\n<p>마지막으로 <code class=\"language-text\">quickSort</code> 함수에 퀵 정렬을 구현해보겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">swap</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">arr<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">,</span> j</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token punctuation\">;</span><span class=\"token punctuation\">[</span>arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>arr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">pivot</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">arr<span class=\"token punctuation\">,</span> start <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> end <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">.</span>length <span class=\"token operator\">+</span> <span class=\"token number\">1</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// arr의 start를 피벗으로 설정합니다.</span>\n  <span class=\"token keyword\">let</span> pivot <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span>start<span class=\"token punctuation\">]</span>\n  \n  <span class=\"token comment\">// swapIdx라는 변수를 선언하고 현재 피벗 인덱스를 할당합니다.</span>\n  <span class=\"token keyword\">let</span> swapIdx <span class=\"token operator\">=</span> start\n\n  <span class=\"token comment\">// 배열의 두번째 요소부터 마지막 요소까지 반복합니다.</span>\n  <span class=\"token comment\">// 이유: 첫번째 요소는 자기 자신이기 때문에 굳이 비교할 필요가 없습니다.</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> start <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> arr<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">//피벗이 현재 요소보다 크면 피벗 인덱스 변수를 증가시킨 다음 현재 요소를 피벗 인덱스에 있는 요소로 바꿉니다.</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pivot <span class=\"token operator\">></span> arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      swapIdx<span class=\"token operator\">++</span>\n      <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span> swapIdx<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">//시작 요소(즉, 피벗)를 피벗 인덱스와 바꿉니다.</span>\n  <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span> start<span class=\"token punctuation\">,</span> swapIdx<span class=\"token punctuation\">)</span>\n\n  <span class=\"token comment\">//피벗 인덱스 반환</span>\n  <span class=\"token keyword\">return</span> swapIdx\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">quickSort</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">arr<span class=\"token punctuation\">,</span> left <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> right <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 요소가 2개 미만인 하위 배열인 경우 재귀함수를 멈춥니다.</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>left <span class=\"token operator\">&lt;</span> right<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 배열에서 피벗 헬퍼를 호출하고, 피벗 인덱스를 반환받습니다.</span>\n    <span class=\"token keyword\">let</span> pivotIndex <span class=\"token operator\">=</span> <span class=\"token function\">pivot</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span> left<span class=\"token punctuation\">,</span> right<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\">// 피벗 인덱스의 왼쪽에 있는 하위 배열에서 피벗 헬퍼를 재귀적으로 호출합니다.</span>\n    <span class=\"token function\">quickSort</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span> left<span class=\"token punctuation\">,</span> pivotIndex <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\">// 피벗 인덱스의 오른쪽에 있는 하위 배열에서 피벗 헬퍼를 재귀적으로 호출합니다.</span>\n    <span class=\"token function\">quickSort</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span> pivotIndex <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> right<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> arr\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<h4>퀵 정렬의 시간 복잡도</h4>\n<p>퀵 정렬의 시간 복잡도는 아래와 같습니다.</p>\n<p>최상: O(n log n)\n평균: O(n log n)\n최악: O(n²)</p>\n<p>먼저 최상과 평균적인 경우를 살펴보겠습니다. 왜 O(n log n)일까요?</p>\n<p>일단 퀵 정렬의 경우 배열의 길이에 따라서 분할 연산이 log n의 비율로 증가합니다.</p>\n<p>피벗과 각 요소를 비교할 경우 배열의 길이에 따라서 n만큼 연산이 증가합니다.</p>\n<p>따라서, O(n log n)의 시간복잡도를 가지게 됩니다.</p>\n<p>그렇다면 최악의 경우는 대체 언제일까요?</p>\n<p>바로 이미 정렬된 배열에 대해서 첫 번째 요소를 피벗으로 삼아 퀵 정렬을 하는 경우입니다.</p>\n<ul>\n<li>정렬된 배열에서 첫 번째 요소를 피벗으로 삼는 경우</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">- 1회차: [1(피벗), 2, 3, 4, 5, 6, 7, 8]\n\n- 2회차: 1 \n          2(피벗), 3, 4, 5, 6, 7, 8\n- 3회차: 1\n          2\n            3(피벗), 4, 5, 6, 7, 8\n- ...          </code></pre></div>\n<p>분할 알고리즘은 O(log n)의 시간 복잡도를 가질 때 효율이 좋은데, 정렬된 배열에서 첫 번째 요소를 피벗으로 삼으면,</p>\n<p>배열의 길이에 따라서 분할 연산의 갯수가 n배 증가합니다.</p>\n<p>분할 연산과 비교 연산이 같이 이뤄질 경우 O(n²)이라는 시간 복잡도가 나오게 됩니다.</p>\n<p>공간 복잡도의 O(log n)입니다.</p>\n<p>합병 정렬의 경우 분할한 배열들이 공간을 차지하는 반면, 퀵 정열의 경우 피벗을 기준으로 분할 연산을 시행하지만 그 요소들을 따로 배열에 저장하지 않기 때문에 O(log n)이라는 공간 복잡도를 갖게 됩니다.</p>\n<h3>기수 정렬(Radix sort)</h3>\n<p>여태까지 살펴본 합병 정렬과 퀵 정렬은 비교 기반의 정렬을 사용했습니다.</p>\n<p>반면 기수 정렬은 비교를 하지 않고 정렬을 수행하는 알고리즘입니다.</p>\n<p>먼저, <a href=\"https://ko.dict.naver.com/#/entry/koko/ceb6c1de8db040249ec4992093001f98\">기수(基數)</a>란 뭘까요?</p>\n<p>네이버 국어 사전에 따르면 '기수란 수를 나타내는 데 기초가 되는 수. 십진법에서는 0에서 9까지의 <code class=\"language-text\">정수</code>를 이른다.'라고 합니다.</p>\n<p>그렇다면 <a href=\"https://ko.wikipedia.org/wiki/%EA%B8%B0%EC%88%98_%EC%A0%95%EB%A0%AC\">기수 정렬</a>이란 0~9까지의 정수를 기준으로 데이터를 정렬하는 알고리즘으로 설명할 수 있을 것 같습니다.</p>\n<p>역시 예시를 살펴보겠습니다.</p>\n<ul>\n<li>\n<p>예시: [10, 24, 98, 567, 234, 9999, 2, 77]를 오름차순으로 기수 정렬하는 경우</p>\n<ul>\n<li>\n<p>1회차: 각 요소의 <code class=\"language-text\">첫번째 자리(1의 자리)</code> 숫자를 기준으로 정렬합니다.</p>\n<ul>\n<li>정렬 전: [10, 24, 98, 567, 234, 9999, 2, 77]</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">0</th>\n<th align=\"center\">1</th>\n<th align=\"center\">2</th>\n<th align=\"center\">3</th>\n<th align=\"center\">4</th>\n<th align=\"center\">5</th>\n<th align=\"center\">6</th>\n<th align=\"center\">7</th>\n<th align=\"center\">8</th>\n<th align=\"center\">9</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">1<code class=\"language-text\">0</code></td>\n<td align=\"center\">-</td>\n<td align=\"center\"><code class=\"language-text\">2</code></td>\n<td align=\"center\">-</td>\n<td align=\"center\">2<code class=\"language-text\">4</code></td>\n<td align=\"center\">-</td>\n<td align=\"center\">-</td>\n<td align=\"center\">56<code class=\"language-text\">7</code></td>\n<td align=\"center\">9<code class=\"language-text\">8</code></td>\n<td align=\"center\">999<code class=\"language-text\">9</code></td>\n</tr>\n<tr>\n<td align=\"center\">-</td>\n<td align=\"center\">-</td>\n<td align=\"center\">-</td>\n<td align=\"center\">-</td>\n<td align=\"center\">23<code class=\"language-text\">4</code></td>\n<td align=\"center\">-</td>\n<td align=\"center\">-</td>\n<td align=\"center\">7<code class=\"language-text\">7</code></td>\n<td align=\"center\">-</td>\n<td align=\"center\">-</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>정렬 후: [10, 2, 24, 234, 567, 77, 98, 9999]</li>\n</ul>\n</li>\n<li>\n<p>2회차: 각 요소의 <code class=\"language-text\">두번째 자리(10의 자리)</code> 숫자를 기준으로 정렬합니다.</p>\n<ul>\n<li>정렬 전: [10, 2, 24, 234, 567, 77, 98, 9999]</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">0</th>\n<th align=\"center\">1</th>\n<th align=\"center\">2</th>\n<th align=\"center\">3</th>\n<th align=\"center\">4</th>\n<th align=\"center\">5</th>\n<th align=\"center\">6</th>\n<th align=\"center\">7</th>\n<th align=\"center\">8</th>\n<th align=\"center\">9</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\"><code class=\"language-text\">1</code>0</td>\n<td align=\"center\"><code class=\"language-text\">2</code>4</td>\n<td align=\"center\">2<code class=\"language-text\">3</code>4</td>\n<td align=\"center\">-</td>\n<td align=\"center\">-</td>\n<td align=\"center\">5<code class=\"language-text\">6</code>7</td>\n<td align=\"center\"><code class=\"language-text\">7</code>7</td>\n<td align=\"center\">-</td>\n<td align=\"center\"><code class=\"language-text\">9</code>8</td>\n</tr>\n<tr>\n<td align=\"center\">-</td>\n<td align=\"center\">-</td>\n<td align=\"center\">-</td>\n<td align=\"center\">-</td>\n<td align=\"center\">-</td>\n<td align=\"center\">-</td>\n<td align=\"center\">-</td>\n<td align=\"center\">-</td>\n<td align=\"center\">-</td>\n<td align=\"center\">99<code class=\"language-text\">9</code>9</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>정렬 후: [2, 10, 24, 234, 567, 77, 98, 9999]</li>\n</ul>\n</li>\n<li>\n<p>3회차: 각 요소의 <code class=\"language-text\">세번째 자리(100의 자리)</code> 숫자를 기준으로 정렬합니다.</p>\n<ul>\n<li>정렬 전: [2, 10, 24, 234, 567, 77, 98, 9999]</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">0</th>\n<th align=\"center\">1</th>\n<th align=\"center\">2</th>\n<th align=\"center\">3</th>\n<th align=\"center\">4</th>\n<th align=\"center\">5</th>\n<th align=\"center\">6</th>\n<th align=\"center\">7</th>\n<th align=\"center\">8</th>\n<th align=\"center\">9</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\">-</td>\n<td align=\"center\"><code class=\"language-text\">2</code>34</td>\n<td align=\"center\">-</td>\n<td align=\"center\">-</td>\n<td align=\"center\"><code class=\"language-text\">5</code>67</td>\n<td align=\"center\">-</td>\n<td align=\"center\">-</td>\n<td align=\"center\">-</td>\n<td align=\"center\">9<code class=\"language-text\">9</code>99</td>\n</tr>\n<tr>\n<td align=\"center\">10</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">24</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">77</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">98</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>정렬 후: [2, 10, 24, 77, 98, 234, 567, 9999]</li>\n</ul>\n</li>\n<li>\n<p>4회차: 각 요소의 <code class=\"language-text\">네번째 자리(1000의 자리)</code> 숫자를 기준으로 정렬합니다.</p>\n<ul>\n<li>정렬 전: [2, 10, 24, 77, 98, 234, 567, 9999]</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">0</th>\n<th align=\"center\">1</th>\n<th align=\"center\">2</th>\n<th align=\"center\">3</th>\n<th align=\"center\">4</th>\n<th align=\"center\">5</th>\n<th align=\"center\">6</th>\n<th align=\"center\">7</th>\n<th align=\"center\">8</th>\n<th align=\"center\">9</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\">-</td>\n<td align=\"center\">-</td>\n<td align=\"center\">-</td>\n<td align=\"center\">-</td>\n<td align=\"center\">-</td>\n<td align=\"center\">-</td>\n<td align=\"center\">-</td>\n<td align=\"center\">-</td>\n<td align=\"center\"><code class=\"language-text\">9</code>999</td>\n</tr>\n<tr>\n<td align=\"center\">10</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">24</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">77</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">98</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">234</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">567</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>정렬 후: [2, 10, 24, 77, 98, 234, 567, 9999]</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>예시에서 각 요소들을 기수(0~9까지의 정수)를 기준으로 분류했는데, 이때 분류를 위해 임시로 사용되는 배열을 <code class=\"language-text\">버킷</code>이라고 부릅니다.</p>\n<p>예시를 봤을 때, 기수 정렬에서 필요한 알고리즘에는 어떤 것들이 있을까요?</p>\n<p>먼저 각 요소의 <code class=\"language-text\">자릿수에 따라 숫자를 구할 수 있는</code> 알고리즘이 필요할 것 같습니다.</p>\n<p>그리고, 예시에서는 9999가 네 자리 숫자로 가장 큰 자릿수를 가지고 있고, 9999의 자릿수를 기준으로 회차가 반복되고 있습니다.</p>\n<p>따라서, <code class=\"language-text\">해당 숫자의 자릿수를 구할 수 있는</code> 알고리즘과, <code class=\"language-text\">배열에서 요소 중 최대 자릿수를 구할 수 있는</code> 알고리즘도 필요할 것 같습니다.</p>\n<h4>기수 정렬의 구현</h4>\n<p>위에서 언급했던 알고리즘들을 각각 <code class=\"language-text\">getDigit</code>, <code class=\"language-text\">digitCount</code>, <code class=\"language-text\">mostDigits</code>라는 헬퍼 함수로 정의하여 기수 정렬을 구현한 <code class=\"language-text\">radixSort</code>라는 함수를 정의해보겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// 입력한 자릿수의 숫자를 알아내기 위한 함수 (예: 7235, 1의 자리 => 5, 10의 자리 => 3)</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">getDigit</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">num<span class=\"token punctuation\">,</span> i</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">floor</span><span class=\"token punctuation\">(</span>Math<span class=\"token punctuation\">.</span><span class=\"token function\">abs</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">pow</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> <span class=\"token number\">10</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 하나의 숫자에 대한 자릿수를 계산하는 함수 (예: 314 => 3자리)</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">digitCount</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">num</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>num <span class=\"token operator\">===</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token number\">1</span>\n  <span class=\"token keyword\">return</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">floor</span><span class=\"token punctuation\">(</span>Math<span class=\"token punctuation\">.</span><span class=\"token function\">log10</span><span class=\"token punctuation\">(</span>Math<span class=\"token punctuation\">.</span><span class=\"token function\">abs</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 숫자 목록의 숫자 중에서 가장 큰 자릿수를 구하는 함수 (예: [1, 22, 333, 4444, 55555] => 5자리)</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">mostDigits</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">nums</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> maxDigits <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    maxDigits <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span>maxDigits<span class=\"token punctuation\">,</span> <span class=\"token function\">digitCount</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> maxDigits\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">radixSort</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">nums</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 가장 큰 숫자의 자릿수가 몇 자리인지 알아냅니다.</span>\n  <span class=\"token keyword\">let</span> maxDigitCount <span class=\"token operator\">=</span> <span class=\"token function\">mostDigits</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span>\n  <span class=\"token comment\">// k = 0에서 이 최대 자릿수까지 반복합니다.</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> k <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> k <span class=\"token operator\">&lt;</span> maxDigitCount<span class=\"token punctuation\">;</span> k<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 루프의 각 반복에 대해 각 숫자(0~9)에 대해 버킷을 생성합니다.</span>\n    <span class=\"token keyword\">let</span> digitBuckets <span class=\"token operator\">=</span> Array<span class=\"token punctuation\">.</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">length</span><span class=\"token operator\">:</span> <span class=\"token number\">10</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\">// 각 숫자를 k번째 숫자를 기준으로 해당 버킷에 배치합니다.</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> nums<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// 기존 배열을 0부터 시작하여 9까지 버킷의 값으로 바꿉니다.</span>\n      <span class=\"token keyword\">let</span> digit <span class=\"token operator\">=</span> <span class=\"token function\">getDigit</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> k<span class=\"token punctuation\">)</span>\n      digitBuckets<span class=\"token punctuation\">[</span>digit<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    nums <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">concat</span><span class=\"token punctuation\">(</span><span class=\"token operator\">...</span>digitBuckets<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> nums\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<h4>기수 정렬의 시간 복잡도</h4>\n<p>기수 정렬의 시간 복잡도는 최상, 최악, 평균 모두 O(nk)입니다.</p>\n<p>여기서 n은 정렬할 정수의 개수, k는 수의 길이(자릿수)입니다.</p>\n<p>정수의 개수에 따라서 연산도 늘어나고, 최대 자릿수를 기준으로 또 다시 반복하기 때문에 O(nk) 시간복잡도를 갖습니다.</p>\n<p>n과 k가 곱해지기 때문에, k의 값이 너무 길어지는 경우에는 성능이 좋지 않습니다.</p>\n<p>하지만 단순하게 생각해봤을 때, 0~99999까지 10만개의 요소를 정렬한다고 해도 k의 값은 겨우 5를 차지합니다.</p>\n<p>적당한 도메인에 최적화된 기수 정렬은 성능이 매우 좋을 수 있습니다.</p>\n<p>공간 복잡도는 O(n + k)입니다.</p>\n<p>각 요소들과 각 기수의 버킷에 따라 공간 복잡도가 상승하기 때문입니다.</p>\n<h3>프로그래머스 문제 적용</h3>\n<p>정렬 알고리즘을 배웠으니 프로그래머스에서 문제를 하나 가져와서 풀어보려고 합니다.</p>\n<p>이번에 가져온 문제는 프로그래머스 코딩테스트 연습 Lv.2 문제 <a href=\"https://school.programmers.co.kr/learn/courses/30/lessons/42746\">가장 큰 수</a>입니다.</p>\n<p>해당 문제는 프로그래머스 사이트의 코딩테스트 고득점 Kit의 <a href=\"https://school.programmers.co.kr/learn/courses/30/parts/12198\">정렬</a> 항목에 있는 문제입니다.</p>\n<p>저는 이 문제를 기수 정렬로 풀 수 있을 거라 생각했는데, 왜 그렇게 생각했는지 문제를 같이 보겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">0 또는 양의 정수가 주어졌을 때, 정수를 이어 붙여 만들 수 있는 가장 큰 수를 알아내 주세요.\n\n예를 들어, 주어진 정수가 [6, 10, 2]라면 [6102, 6210, 1062, 1026, 2610, 2106]를 만들 수 있고, \n\n이중 가장 큰 수는 6210입니다.\n\n0 또는 양의 정수가 담긴 배열 numbers가 매개변수로 주어질 때, \n\n순서를 재배치하여 만들 수 있는 가장 큰 수를 문자열로 바꾸어 return 하도록 solution 함수를 작성해주세요.</code></pre></div>\n<p>이 문제는 주어진 배열을 단순히 내림차순으로 정렬한 다음 문자열로 합치면 되는 문제는 아닙니다.</p>\n<p>예를 들어 [3, 30, 34, 5, 9] 라는 배열을 내림차순 정렬한 다음 문자열로 합치면 \"3430953\"이 될텐데,</p>\n<p>\"3430953\"는 해당 배열에서 만들 수 있는 가장 큰 수가 아닙니다.</p>\n<p>해당 배열에서 만들 수 있는 가장 큰 수는 [9, 5, 34, 30, 3] 으로 정렬한 다음 문자열로 합친 \"9534330\" 입니다.</p>\n<p>[9, 5, 34, 30, 3]으로 정렬된 배열을 보니 저는 이런 아이디어가 떠올랐습니다.</p>\n<ol>\n<li>해당 숫자의 맨 앞의 자릿수를 기준으로 버킷을 나누고</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[3, 30, 34, 5, 9] => [[9], [5], [3, 30, 34]]</code></pre></div>\n<ol start=\"2\">\n<li>버킷의 길이가 2 이상이라면 다음 자릿수를 기준으로 또 다시 버킷을 나눈다.</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[[9], [5], [3, 30, 34]] => [[9], [5], [[34], [3], [30]]]</code></pre></div>\n<ol start=\"3\">\n<li>더 이상 나눌 버킷이 없다면 배열을 합친다.</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[[9], [5], [[34], [3], [30]]] => [[9], [5], [34, 3, 30]] => [9, 5, 34, 3, 30]</code></pre></div>\n<p>결론부터 말하면 제 아이디어로는 <code class=\"language-text\">코딩 테스트를 통과할 수 없었습니다.</code></p>\n<p>먼저, 이 아이디어를 구현했던 코드를 먼저 보겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// 하나의 숫자에 대한 자릿수를 계산하는 함수 (예: 314 => 3자리)</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">digitCount</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">num</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>num <span class=\"token operator\">===</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token number\">1</span>\n  <span class=\"token keyword\">return</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">floor</span><span class=\"token punctuation\">(</span>Math<span class=\"token punctuation\">.</span><span class=\"token function\">log10</span><span class=\"token punctuation\">(</span>Math<span class=\"token punctuation\">.</span><span class=\"token function\">abs</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 입력한 자릿수의 숫자를 알아내기 위한 함수 (예: 7235, 1의 자리 => 5, 10의 자리 => 3)</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">getDigit</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">num<span class=\"token punctuation\">,</span> i</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">floor</span><span class=\"token punctuation\">(</span>Math<span class=\"token punctuation\">.</span><span class=\"token function\">abs</span><span class=\"token punctuation\">(</span>num<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">pow</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> <span class=\"token number\">10</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 기수 정렬 알고리즘</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">radixSort</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">numbers<span class=\"token punctuation\">,</span> k</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> digitBuckets <span class=\"token operator\">=</span> Array<span class=\"token punctuation\">.</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">length</span><span class=\"token operator\">:</span> <span class=\"token number\">10</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    numbers<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">number</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">const</span> maxDigit <span class=\"token operator\">=</span> <span class=\"token function\">digitCount</span><span class=\"token punctuation\">(</span>number<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> k \n            <span class=\"token keyword\">const</span> currentDigit <span class=\"token operator\">=</span> maxDigit <span class=\"token operator\">>=</span> <span class=\"token number\">0</span> <span class=\"token operator\">?</span> maxDigit <span class=\"token operator\">:</span> maxDigit <span class=\"token operator\">+</span> <span class=\"token number\">1</span>\n            <span class=\"token keyword\">let</span> digit <span class=\"token operator\">=</span> <span class=\"token function\">getDigit</span><span class=\"token punctuation\">(</span>number<span class=\"token punctuation\">,</span> currentDigit<span class=\"token punctuation\">)</span>\n            digitBuckets<span class=\"token punctuation\">[</span><span class=\"token number\">9</span> <span class=\"token operator\">-</span> digit<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>number<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> digitBuckets\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 버킷의 길이가 2 이상인 배열에 대해서 기수 정렬을 재귀적으로 시행할 함수</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">getSortedArray</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">arr<span class=\"token punctuation\">,</span> k</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>k <span class=\"token operator\">===</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    arr<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">bucket<span class=\"token punctuation\">,</span> index<span class=\"token punctuation\">,</span> array</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>bucket<span class=\"token punctuation\">.</span>length <span class=\"token operator\">></span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">let</span> inner <span class=\"token operator\">=</span> <span class=\"token function\">radixSort</span><span class=\"token punctuation\">(</span>bucket<span class=\"token punctuation\">,</span> k<span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">let</span> result <span class=\"token operator\">=</span> <span class=\"token function\">getSortedArray</span><span class=\"token punctuation\">(</span>inner<span class=\"token punctuation\">,</span> k <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n            array<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">concat</span><span class=\"token punctuation\">(</span><span class=\"token operator\">...</span>result<span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> arr\n<span class=\"token punctuation\">}</span>\n\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">solution</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">numbers</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    \n    <span class=\"token keyword\">let</span> answer <span class=\"token operator\">=</span> <span class=\"token string\">\"\"</span>\n    \n    <span class=\"token comment\">// 1차적으로 기수 정렬을 합니다.</span>\n    <span class=\"token keyword\">let</span> digitBuckets <span class=\"token operator\">=</span> <span class=\"token function\">radixSort</span><span class=\"token punctuation\">(</span>numbers<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    \n    <span class=\"token comment\">// 1차 기수 정렬된 배열의 버킷 중 길이가 2 이상인 버킷에 대해서 기수 정렬을 재귀적으로 시행합니다.</span>\n    <span class=\"token keyword\">let</span> recursionSortedArr <span class=\"token operator\">=</span> <span class=\"token function\">getSortedArray</span><span class=\"token punctuation\">(</span>digitBuckets<span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n    \n    <span class=\"token comment\">// 반환된 배열을 평탄화합니다.</span>\n    <span class=\"token keyword\">let</span> flatteningArr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">concat</span><span class=\"token punctuation\">(</span><span class=\"token operator\">...</span>recursionSortedArr<span class=\"token punctuation\">)</span>\n    \n    <span class=\"token comment\">// 평탄화된 배열을 문자열로 합쳐서 반환합니다.</span>\n    flatteningArr<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">number</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n        answer <span class=\"token operator\">+=</span> <span class=\"token function\">String</span><span class=\"token punctuation\">(</span>number<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    \n    <span class=\"token keyword\">return</span> answer\n    \n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>기본 예시로 주어진 [6, 10, 2]와 [3, 30, 34, 5, 9]는 통과할 수 있었지만,</p>\n<p>제출 후에 이뤄진 정확성 테스트 15개 중 5개만 통과하고 나머지 10개는 런타임 에러가 발생했습니다.</p>\n<p>생각해보면 당연합니다.</p>\n<p>배열의 버킷을 10개로 나누는데, 길이에 따른 제한을 뒀다고 해도 각 버킷마다 또 다시 10개로 나누고, 버킷이 최대로 나눠질 때까지 이를 재귀적으로 반복한다면, 정말 많은 연산이 일어날 것입니다.</p>\n<p>다양한 방법으로 4시간을 넘게 고민해봤지만, 현재 제 능력으로는 기수 정렬을 활용해서 풀 수 없다고 판단했습니다.</p>\n<p>일단 다른 방법으로 풀었고, 해당 문제를 푼 다른 사람의 풀이를 쭉 훑어보니, '패터쓴'이라는 닉네임을 사용하신 분께서 기수 정렬 아이디어로 문제를 해결하신 것을 보게되었습니다.</p>\n<p>그래서 이번에는 '패터쓴'님이 작성한 풀이를 분석하는 것으로 상세 풀이를 대체하려고 합니다.</p>\n<p>참고로, 코드 원문의 경우 변수명이 단일 알파벳으로 이뤄져 있었는데, 저 스스로 이해하기 위해 변수명을 수정했습니다.</p>\n<p>'패터쓴'님의 코드 원문이 궁금하신 분들은 '프로그래머스 코딩테스트 연습 Lv.2 문제 <a href=\"https://school.programmers.co.kr/learn/courses/30/lessons/42746\">가장 큰 수</a>'에서 '다른 사람의 풀이'를 확인해보시면 되겠습니다.</p>\n<h4>문제 해결 접근법과 상세 풀이</h4>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">/* \n- 인풋\n  - numbers: 1~100,000 사이의 길이를 갖는 배열로, 각 원소는 0~1,000 사이의 값을 갖는다.\n*/</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">solution</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">numbers</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  \n  <span class=\"token comment\">// 기수 정렬할 요소를 담을 배열 buckets를 선언하고 빈 배열을 할당합니다.</span>\n  <span class=\"token keyword\">const</span> buckets <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> number <span class=\"token keyword\">of</span> numbers<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// number를 문자열로 변환합니다.</span>\n    <span class=\"token keyword\">const</span> str <span class=\"token operator\">=</span> <span class=\"token function\">String</span><span class=\"token punctuation\">(</span>number<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\">// number의 최대 자릿수를 체크하기 위해 길이를 변수로 할당합니다.</span>\n    <span class=\"token keyword\">const</span> length <span class=\"token operator\">=</span> str<span class=\"token punctuation\">.</span>length\n\n    <span class=\"token comment\">// number가 buckets에 들어갈 위치가 될 변수 index를 선언하고 빈 문자열을 할당합니다.</span>\n    <span class=\"token keyword\">let</span> index <span class=\"token operator\">=</span> <span class=\"token string\">\"\"</span>\n\n    <span class=\"token comment\">// str의 1의 자리 숫자부터 4의 자리까지의 숫자까지 순회하면서 각 자릿수의 숫자로 인덱스를 만듭니다.</span>\n    <span class=\"token comment\">// 예를 들어 str이 \"1000\"이라면, 인덱스는 \"1000\"이 됩니다.</span>\n    <span class=\"token comment\">// 만약 str이 1의 자리 숫자라면 1의 자리 숫자만으로 인덱스를 채웁니다.</span>\n    <span class=\"token comment\">// 예를 들어 str이 \"3\"이라면, 인덱스는 \"3333\"이 됩니다.</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> digit <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> digit <span class=\"token operator\">&lt;</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span> digit<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>length <span class=\"token operator\">></span> digit<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        index <span class=\"token operator\">+=</span> str<span class=\"token punctuation\">[</span>digit<span class=\"token punctuation\">]</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        index <span class=\"token operator\">+=</span> str<span class=\"token punctuation\">[</span>digit <span class=\"token operator\">%</span> length<span class=\"token punctuation\">]</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\">// [3, 30, 34, 5, 9]의 각 원소들은 아래와 같은 index를 가집니다.</span>\n    <span class=\"token comment\">// 3: 3333</span>\n    <span class=\"token comment\">// 30: 3030</span>\n    <span class=\"token comment\">// 34: 3434</span>\n    <span class=\"token comment\">// 5: 5555</span>\n    <span class=\"token comment\">// 9: 9999</span>\n    \n\n    <span class=\"token comment\">// 인덱스가 큰 값이 배열의 앞으로 오도록 정렬합니다.</span>\n    index <span class=\"token operator\">=</span> <span class=\"token number\">9999</span> <span class=\"token operator\">-</span> index\n\n    <span class=\"token comment\">// 해당 인덱스 값을 활용하여 buckets에 str을 추가합니다.</span>\n    buckets<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> buckets<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span> <span class=\"token operator\">?</span> buckets<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> str <span class=\"token operator\">:</span> str\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">// 현재 buckets의 모습은 아래와 같습니다.</span>\n  <span class=\"token comment\">/*\n  [ '9', &lt;4443 empty items>,\n    '5', &lt;2120 empty items>,\n    '34', &lt;100 empty items>,\n    '3', &lt;302 empty items>,\n    '30'\n  ]\n  */</span>\n\n  <span class=\"token comment\">// buckets의 모든 요소를 연결해 하나의 문자열로 만듭니다.</span>\n  <span class=\"token keyword\">const</span> answer <span class=\"token operator\">=</span> buckets<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span>\n\n  <span class=\"token comment\">// numbers의 원소가 2개 이상의 0으로만 이뤄져 있는 예외 사항을 처리합니다.</span>\n  <span class=\"token keyword\">return</span> answer<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">===</span> <span class=\"token string\">\"0\"</span> <span class=\"token operator\">?</span> <span class=\"token string\">\"0\"</span> <span class=\"token operator\">:</span> answer\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<h3>회고</h3>\n<p>똑같이 기수 정렬을 배웠는데, 저는 왜 이런 아이디어를 떠올리지 못 했을까요?</p>\n<p>제 생각에는 저 자신이 강의에서 배운 내용에서 벗어나지 못 했기 때문이라고 생각합니다.</p>\n<p>강의에서 알려준 절차를 그대로 적용했지만 문제가 풀리지 않을 때, 거기에서 조금이라도 다른 방식으로 생각해보는 것이 현재로서는 어려운 것 같습니다.</p>\n<p>'이런 쪽에 재능이 없는 건가?'라는 살짝 우울한 생각이 들 때 쯤, 이런 생각을 예전에도 했던 것 같다는 생각이 들었는데,</p>\n<p>그 때가 바로 클론 코딩 강의 수강 후에 나만의 프로젝트를 만들 때였던 것 같습니다.</p>\n<p>클론 코딩 강의를 듣고 따라 만들 때는 아무런 문제가 없었지만, 완전히 다른 프로젝트를 만들기 시작하니 정말 수많은 에러를 만났습니다.</p>\n<p>'나는 그 때 어떻게 했더라?'라고 생각해보니, 구글과 MDN 검색, 모딥다 찾아보기 등 여러 레퍼런스를 참고하며 에러를 해결했고, 그 과정 중에서 많이 배웠던 기억이 있습니다.</p>\n<p>그러면 코딩테스트도 마찬가지 아닐까 싶습니다.</p>\n<p>지금은 배운 알고리즘과 자료구조도 겨우 적용해보면서 문제를 풀고 있지만, 도저히 못 풀겠을 때는 다른 사람의 풀이도 참고하고, 혹시 문제를 풀었더라도 더 좋은 방법은 없을지 검색해가면서 배우면 되지 않을까요?</p>\n<p>스스로 풀지 못 한 것은 분명 실패지만, 그 실패가 성장을 위한 발판이라 생각하며 오늘은 여기서 마치겠습니다.</p>\n<p>감사합니다.</p>\n<h3>참고자료</h3>\n<ul>\n<li>프로그래머스 코딩 테스트 연습 - K번째수</li>\n</ul>\n<p>문제 링크: <a href=\"https://school.programmers.co.kr/learn/courses/30/lessons/42748\">https://school.programmers.co.kr/learn/courses/30/lessons/42748</a></p>\n<ul>\n<li>Best JavaScript Data Structures &#x26; Algorithms Course by Udemy, last updated January 2022, accessed April 5, 2023</li>\n</ul>\n<p>강의 링크: <a href=\"https://www.udemy.com/course/best-javascript-data-structures/\">https://www.udemy.com/course/best-javascript-data-structures/</a></p>","frontmatter":{"title":"알고리즘 & 자료구조 스터디 9주차","date":"May 31, 2023","description":"스터디 9주차 내용 정리와 회고입니다.","mobileImage":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABo0lEQVR42l2SW0vDQBCF82/rg0KxSJW+iaXqa7Xa5rK9KGovSWNMN0mb1kv9Cz4KgvgiqCCCinJk9lKChaFDZvabc3bWMAcclhuBDRPx3+iPYLuRyOu9ENaAw3a5ykdwvEjUqY96KK+r3PFiGAR0hrEEebEEC0iEVpCiHV6idTFDM5jiJJ7DGY5Fjc5YruxjKqcwiExQPZFgZn+E9kWKyp6JXH4Npa0KNjbLyOULKFcbYP5k0U+qLDWAxEiFnpygi9RsujGqVgvThGN2NUeU3iBNYlRNBltcDxdCsiEs02Gik11SR/KZn+CwF8KPUtDv7hV4eXsC8IsBn6F2Fgg1FASx1b2SmH+WuSpwHHRDDEYJHj7f8f31DOADP4/36J5HomarcwvbimFoOstcslxUgn3WwWnQRxq0MU0T3Ho+6qwDU6nRNvXLaPoJKeTSriu3TSGBY+zUHCyvFrFUKGGlWMJ6eRu7hwytYCIAJCbrTijMvjsqElxPJuhxdI0jLp8ObZeU6z69SN1P3wySqSEaTEOY2mSjH8IUDzpe2LMyfWKhGTF/ZXxbdhmpbtsAAAAASUVORK5CYII="},"backgroundColor":"transparent","images":{"fallback":{"src":"/static/6d2bce79832bb7a2be88fc055572e63e/a22c4/algorithm-512x256x2.png","srcSet":"/static/6d2bce79832bb7a2be88fc055572e63e/cadb4/algorithm-512x256x2.png 750w,\n/static/6d2bce79832bb7a2be88fc055572e63e/a22c4/algorithm-512x256x2.png 856w,\n/static/6d2bce79832bb7a2be88fc055572e63e/7a9e5/algorithm-512x256x2.png 1024w","sizes":"(min-width: 856px) 856px, 100vw"},"sources":[{"srcSet":"/static/6d2bce79832bb7a2be88fc055572e63e/0b163/algorithm-512x256x2.avif 750w,\n/static/6d2bce79832bb7a2be88fc055572e63e/1167a/algorithm-512x256x2.avif 856w,\n/static/6d2bce79832bb7a2be88fc055572e63e/02545/algorithm-512x256x2.avif 1024w","type":"image/avif","sizes":"(min-width: 856px) 856px, 100vw"},{"srcSet":"/static/6d2bce79832bb7a2be88fc055572e63e/11ba1/algorithm-512x256x2.webp 750w,\n/static/6d2bce79832bb7a2be88fc055572e63e/024d1/algorithm-512x256x2.webp 856w,\n/static/6d2bce79832bb7a2be88fc055572e63e/25be2/algorithm-512x256x2.webp 1024w","type":"image/webp","sizes":"(min-width: 856px) 856px, 100vw"}]},"width":856,"height":428}}}}},"previous":{"fields":{"slug":"/algorithm-study/8-week/"},"frontmatter":{"title":"알고리즘 & 자료구조 스터디 8주차"}},"next":null},"pageContext":{"id":"894d0b24-d127-5681-8f48-d924a94bcefe","previousPostId":"6fc4f7e6-30d4-50b0-9b39-57ae85429c07","nextPostId":null}},"staticQueryHashes":["2841359383"],"slicesMap":{}}